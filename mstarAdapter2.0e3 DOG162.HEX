;**********************************************************************
;                                                                     *
;**********************************************************************
;  
;    Filename:	    MStar.asm 
; 
;    Author:  Gordon Anderson
;    Company: GAA Custom Electronics
;
;    The MicroStar 2000 is a model airplane encoder. An encoder reads
;    the joy stick pots and the switches and generates the modulation
;    signal sent to the RF deck, the other significant part of a
;    transmitter.
;
;    This project started in 2000 with the first software release in January
;    of 2001.
;
;    The PIC processor has several pages or banks of ram. Each is 256
;    bytes long. These banks are used as follows:
;    Bank0:
;          Contains all of the working variables. None of this information
;          is saved, and on powerup its in a undefined state.
;    Bank1:
;          Used for misc variables.
;    Bank2:
;          This bank contains all of the general parameters. These are
;          the parameters that are constant for all aircraft settings,
;          like joy stick calibration. This information is saved in the
;          configuration area of flash memory.
;    Bank3 and Bank4:
;          These banks contain the aircraft specific data. These 
;          parameters are read from the flash memory on powerup or when
;	   a new aircraft configuration is selected.
;    Bank5:
;          This bank holds a working copy of all EEprom parameters.
;    Bank6 and Bank7:
;	   These banks are used to hold the aircraft specfic data used when
;          alternate aircraaft mode.
;    Bank8:
;          This bank is used for the aircraft name function.
;
;
;    Flash memory
;	The flash memory is used to store general parameters and aircraft specific
;	setup parameters. 256 bytes are used for general parameters, This
;	is the size of bank 2 and all general parameters are in bank 2.
;	512 bytes are also used for each of the 96 aircraft setups that 
;	can be saved in the flash. The aircraft setting are saved in banks
;	3 and 4. On powerup the general parameters are loaded then the aircraft
;	specified is loaded.
;       This flash memory is the same memory used to hold the MicroStar PIC application
;       code.
;
;    Startup options:
;
;       Press OPTION + PRESET   = Start the IO test routine
;       Press PRESET + AUTOTRIM = bypass sprom load and load from
;                                 default table. This is designed 
;                                 for initial startup with a new sprom.
; BUG report:
;;
; Revision History:
;	All fo the version 1.0 revesions were for the orginal Encoder design that had
;	a final hardware revision of 3.0. Versions 2.0 are all designed for the hardware
;	revision 4.0 and beyond. This revision uses the PIC 18F8722 PIC. The orginal 
;	encoder used a 17C766 PIC and the version 2.0 series is not compatable with that
;	PIC.
;
;	Version 1.0b
;		First release, Jan 2001
;	Version 1.0c
;		Fixed a few minor bugs and finished the dual SPROM
;		support
;       Version 1.0d, Jan 28, 2001
;               Fixed a timming put in the SPROM read function.
;       Version 1.0E, April 16,2001
;               Fixed the interface to RF deck, added support for
;		50MHz, 53MHz, and 72MHz.         
;		Added support for the receiver battery test function.
;       Version 1.0F, May 5, 2001
;               Placed the PLL in high current mode.
;               Fixed a display bug in the LCD52 drivers.   
;               Small display bug in 4x12 display driver.
;	Version 1.0G, October 21, 2001
;		Added programmable channel output order
;		Added Programmable trim assignment
;		Added support for Futaba type buddy box
;		Added new Auto Trim mode, where full adjustment is made when button
;		is pressed
;		Added enable switch to timer and throttle trigger to timer
;		Added up counter mode
;       Version 1.0H, March 17, 2002
;               Fixed a bug in the throttle trim, the percentage value used
;               was from the rudder!
;               Added a timer option to stop at zero on down counting.
;               Fixed bug in UP counter.
;       Version 1.0I, August 18, 2002
;               1.) Servo limits changed to .750 mS and 2.250 mS
;               2.) Snap PB changed to % and done after normalization
;               3.) CROW added
;	Version 1.0J, November 30, 2003
;		1.) Fixed a bug in the table edit mode that would not
;		    allow you to edit the last position.
;		2.) Fixed the Fixed First Mixer bug.
;	Version 1.1a, December 2004
;		1.) Added high and low rate expo to A,E,R (tested)
;		2.) Fixed the alt aircraft timer problem (tested)
;		3.) Added the Throttle low point adjust feature (tested)
;		4.) Added second alternate aircraft switch (tested)
;		5.) Add set model to default parameters (tested)
;		6.) Add buttons to set time values in min and max as short cuts.
;		    use snap right and snap left buttons. (tested)
;		6.) Add battery timer (tested)
;		7.) Add FMS flight simulator support (tested)
;		8.) Channel trigger points (tested)
;		9.) Add battery alarm level adjustment (tested)
;		10.)Reorder the menus into a more logical order (tested)
;		11.)Add 4 more tables (tested)
;		12.)Move Shift setting to Aircraft area (tested)
;		13.)Fix bug in the Frequency selection function, can not 
;		    select OFF as an option. (tested)
;		14.)Changed the way Mixer 2 works. (tested)
;		15.)Bug that causes the transmitter to crash in CAL mode when
;		    a mixer is on. I think it was the select chan functions mult.
;		    (tested)
;	Version 1.1b, January 14, 2005, bug fixes only
;		1.) Fixed a EPROM space bug
;		2.) Det defaults for min and max value
;		3.) Fixed AUXOUT on top line of display
;	Version 1.1c, Feburary 12 2005, bug fix
;		1.) Fixed bug in AutoTrim one shot mode if you have full
;		    stick deflection.
;	Version 1.1d, July 7 2005, requests, not yet implemented
;		Found and fixed a servo position editing bug. This had
;               to do with block move using wrong radix. 
;	Version 1.1e, July 24 2005
;		Found and fixed a aileron differential bug
;	Version 1.1f, December 10 2005
;		Found and fixed a channel 8 bug that caused the programed values to
;		be off by a factor of two from center
;
;	Version 2.0a, December 2006.
;		1.) Move channel order to aircraft memory area, done
;		2.) Auto Trim range increase to +- 20 percent, done
;		3.) Use preset button as an exit from UI, done
;		4.) Move tables to Aircraft area (2 tables added, 22 bytes), done
;		5.) Add fixed mixers (12 bytes total), done
;			- Ail to rudder, 2 bytes
;			- Rud to ail, 2 bytes
;			- Rud to ele, 2 bytes
;			- Throttle to ele, 1 byte
;			- Dual elevator, 2 bytes
;		6.) Add sub trims, 8 bytes, done
;		7.) Fix the format flash functions to sync with ppm signal output, done
;		8.) Change invert function to say, positive/negative, done
;	Version 2.0b, January 2007
;		1.) Fixed bug with both LEDs
;		2.) Fixed bug in transmitter voltage adjust
;		3.) Fixed bug in throttle servo position set
;		4.) Added the Adapter assembley switch
;	Version 2.0c, March 2007
;		1.) Fixed bug in copy aircraft, limited aircraft number to 8.
;		2.) Added the frequency band selection menu options to replance jumpers,
;	Version 2.0d, April 8 2007
;		1.) Alternate aircraft number problem. 0 is allowed, look at copy 
;		    function as well. Fixed copy bug, 0 is OK in alt aircraft define
;		    zero disables function
;		2.) Power up student mode throttle adjust lockup, added clear to TTflag
;		    on powerup
;		3.) Elevon bug, aileron channel is dead
;		4.) VTAIL bug, rudder is dead
;		5.) For elevaon and vtail remove the code to divide throws in half
;	Version 2.0e
;		1.) Added variable rate to mS change function, done and tested
;		2.) Fixed subtrim bug, they were not working at all due to indirect reg being
;		    overwritten. Fixed and tested
;		3.) Bug with the on time counter, in process need to add init to format function
;		4.) Fixed ADC reference problems, done
;		5.) Test auto trims, done 
;		6.) Changed channel 5,6,7, and 8 to be -1000 to 1000 range. This makes the
;		     better and allows the end points adjustments to work on dual A and E. Done
;		     and tested except for the dual A & E options.
;	Version 2.0e2, Feb 3, 2008
;		1.) Fix a bug with the joystick center determination function. It was before the 
;		    configuration parameters were read causing a bug when the ref is changed to 
;		    5 volts.
;	Version 2.0e3, March 16 2008
;		1.) Added an option to invert the buzzer polarity. This is to allow a vibrator to
;		    be used in place of the buzzer on the rev 4.0 encoder.
;	Version 2.0f, to do list
;		1.) Add more aircraft specific tables, 7 total. Can't have more than 7
;		    aircraft tables. here is what needs to be done for this change:
;			a.) Move the aircraft tables to the end of page 4 in the aircraft setup area.
;			    reserve the old space so we don't have to addjust pointers.
;			b.) Add the 5 additional entries in the data.asm file
;			c.) Edit the PC app to support the new tables and set defaults
;			d.) Test this function
;		2.) Increase auto trim range and step size, it is now +- 20 percent.Make the 
;		    step size a range multiplier as well.
;		3.) and i just remembered another thing i don't find so user friendly:  
;		    whenever i need to adjust something in one of the alternate aircraft 
;		    memories i have to first call up and select that memory.  with the new 
;		    version's 6 alternates this could turn into a real nighmare.  could it 
;		    be changed so that whenever you switch to CAL mode you're automatically 
;		    in the menu of whatever memory was currently being used and displayed on 
;		    the LCD when the switch was hit?
;			Need to consider options for this problem. Faster aircraft channel
;			selection may be an option.
;		4.) Allow no confirm of RF at startup. Do this by adding a EEPROM config function
;		    to the bootloader. Allow the following types of functions or at least consider
;		    these functions:
;			a.) The no RF confirm option
;			b.) Display type
;			c.) Oversampling
;		5.) change snap buttons to allow sticks to still function.
;
;
; Upgrade ideas (many of these are user ideas, so I will implement so I will not.):
;	1.) New trainer mode where the master can influence the student...
;	2.) Programmable delay when switching between flight configurations.
;	3.) Slow servo travel option for retracts
;	4.) Beep when the trims are set to zero.
;
; 
; ***********************************************************************
; *
; *                       GAA Custom Electronics                        
; *                     SOFTWARE LICENSE AGREEMENT
; *
; *
; *     BY USING THIS SOFTWARE, YOU ARE AGREEING TO BE BOUND BY THE TERMS
; *     OF THIS AGREEMENT.  DO NOT USE THE SOFTWARE UNTIL YOU HAVE CAREFULLY
; *     READ AND AGREED TO THE FOLLOWING TERMS AND CONDITIONS.  IF YOU DO
; *     NOT AGREE TO THE TERMS OF THIS AGREEMENT, PROMPTLY RETURN THE
; *     SOFTWARE PACKAGE AND ANY ACCOMPANYING ITEMS.
; *
; *     IF YOU USE THIS SOFTWARE, YOU WILL BE BOUND BY THE TERMS OF THIS
; *     AGREEMENT
; *
; *     LICENSE: GAA Custom Electronics ("GAACE") grants you the non-exclusive
; *     right to use the enclosed software program ("Software").  You will
; *     not use, copy, modify, rent, sell or transfer the Software or any
; *     portion thereof, except as provided in this Agreement.
; *
; *     User System Developers may:
; *
; *     1.      Copy the Software for support, backup or archival purposes;
; *     2.      Install, use, or distribute GAACE owned Software in object
; *             code only for use on a single computer system; 
; *     3.      Modify and/or use Software source code that GAACE directly
; *             ships to you for your personal use only.
; *     4.      Install, use, modify, distribute, and/or make or have made 
; *             derivatives ("Derivatives") of GAACE owned Software under the 
; *             terms and conditions in this Agreement, ONLY if you are an
; *             an end-user.
; *
; *
; *     RESTRICTIONS:
; *
; *     YOU WILL NOT:
; *
; *     1.     Copy the Software, in whole or in part, except as provided 
; *            for in this Agreement;
; *     2.     Decompile or reverse engineer Software provided in object code
; *            format;
; *
; *     TRANSFER:  You may transfer the Software to another party if the
; *     receiving party agrees to the terms of this Agreement at the sole
; *     risk of any receiving party.
; *
; *     OWNERSHIP AND COPYRIGHT OF SOFTWARE:  Title to the Software and all
; *     copies thereof remain with GAA Custom Electronics.  The Software
; *     copyright has been filed and will be protected by United States and 
; *     international copyright laws.  You will not remove the copyright 
; *     notice from the Software.  
; *     You agree to prevent any unauthorized copying of the Software.
; *
; *     DERIVATIVE WORK:  Users that make or have made Derivatives will not be 
; *     required to provide GAACE with a copy of the source or object code. 
; *     Users are not authorized to market, sell, and/or distribute 
; *     derivatives works without the written permission of GAACE.
; *
; *     WARRANTY:  GAACE warrants that it has the right to license you to
; *     use, modify, or distribute the Software as provided in this Agreement.
; *     The Software is provided "AS IS". GAACE warrants that the media on
; *     which the Software is furnished will be free from defects in material
; *     and workmanship for a period of one (1) year from the date of 
; *     purchase. Upon return of such defective media, GAACE's entire 
; *     liability and your exclusive remedy shall be the replacement of the 
; *     Software.
; *
; *     THE ABOVE WARRANTIES ARE THE ONLY WARRANTIES OF ANY KIND EITHER
; *     EXPRESS OR IMPLIED INCLUDING WARRANTIES OF MERCHANTABILITY OR FITNESS
; *     FOR ANY PARTICULAR PURPOSE.
; *
; *     LIMITATION OF LIABILITY:    NEITHER GAACE NOR ITS VENDORS OR AGENTS
; *     SHALL BE LIABLE FOR ANY LOSS OF PROFITS, LOSS OF USE, LOSS OF DATA,
; *     INTERRUPTION OF BUSINESS, NOR FOR INDIRECT, SPECIAL, INCIDENTAL OR
; *     CONSEQUENTIAL DAMAGES OF ANY KIND WHETHER UNDER THIS AGREEMENT OR
; *     OTHERWISE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
; *
; *     TERMINATION OF THIS LICENSE:  GAACE reserves the right to conduct or
; *     have conducted audits to verify your compliance with this Agreement.
; *     GAACE may terminate this Agreement at any time if you are in breach
; *     of any of its terms and conditions.  Upon termination, you will
; *     immediately destroy, and certify in writing the destruction of, the
; *     Software or return all copies of the Software and documentation to
; *     GAACE.
; *
; ************************************************************************
;

	list      p=18F8722            ; list directive to define processor
	#include <P18F8722.INC>         ; processor specific variable definitions
	errorlevel 2
	
;	CONFIG   OSC = HS,BOR = ON,PWRT = OFF,WDT = OFF,MODE = MC,OSCS = ON,DEBUG = OFF

; '__CONFIG' directive is used to embed configuration data within .asm file.
; The lables following the directive are located in the respective .inc file.
; See respective data sheet for additional information on configuration word.

;******************************************************************************
;******************************************************************************
;******************************************************************************
;
; MicroStar configuration options
;
;      These are switches that you can use to define the type MicroStar
;      firmware you wish to build. After you set these options you need
;      to rebuild the application using MPLAB from microchip.
;
; Uncomment this define if you wish to build the version of this code desiged
; for the rev 3.0 encoder upgrade adapter
 #define		ADAPTER
;
; The display type is defined by un-commenting one of the following three
; lines, only one can be un-commented!
 #define		LCD52display
 #define		DOG162			; This switch requires LCD52display
; #define		SED1230display
; #define		ECMA1010display
;
; The following line should be commented out unless you are going to use
; proline type wheel trims
;  #define		PROLINE
;
; Please leave this line un-commented, it deals with how the ADC sticks
; are read.
  #define               ENABLEOVERSAMPLE      
 
; Misc options
; #define			CountOn		; Turns on timer on powerup
;
;******************************************************************************
;******************************************************************************
;******************************************************************************

#define		MOVFP	MOVF
#define		MOVLR	MOVLB
#define		MOVPF	MOVFF
#define		ALUSTA	STATUS

OFFSET	EQU	0x200		; For use with the bootloader
;OFFSET	EQU	0x0		; For stand along operation

; ADC channel assignments
;
;	CH	Use
;	0	Vpos monitor
;	1	Gnd
;	2	CH7
;	3	CH6
;	4	Aileron
;	5	Elevator
;	6	Rudder
;	7	Throttle
;	8	Aileron trim
;	9	Elevator trim
;	10	Rudder trim
;	11	Throttle trim
;	12	+5 volt monitor 
;       13	Receiver voltage monitor
;

NumAircraft	EQU	D'96'

BNK1	EQU	100
BNK2	EQU	200
BNK3	EQU	300
BNK4	EQU	400

; Misc constants
StickThres      EQU     D'100'
AutoTrimOStime	EQU	D'40
VoltageLimit	EQU	D'8800'

; PLL constants
HICUR   EQU     10

; Display Line numbers
ifdef		LCD52display
LINE1      EQU       080
LINE2      EQU       0C0
LINE3      EQU       0C0
CURSORON   EQU       0E
CURSOROFF  EQU       0C
YPOS       EQU       08
YNPOS      EQU       0C
NPOS       EQU       0F
ACFTPOS    EQU       0D
BYTEPOS    EQU       0D
PERCENTPOS EQU       0B
uSPOS      EQU       09
SELCHPOS   EQU       0C
CVMPOS     EQU       0B
ONTIMEPOS  EQU       0B
CH53POS    EQU       08
CH50POS    EQU       0E
CH72POS    EQU       0D
CH50MHZPOS EQU       04
CH72MHZPOS EQU       04
TESTCHPOS  EQU       07
TESTVALPOS EQU       0C
TACHRPMPOS EQU       0B
RECVPOS    EQU       0B
endif

ifdef           SED1230display
LINE1      EQU       0B0
LINE2      EQU       0C0
LINE3      EQU       0C0
CURSORON   EQU       03F
CURSOROFF  EQU       031
YPOS       EQU       08
YNPOS      EQU       0C
NPOS       EQU       0F
ACFTPOS    EQU       0D
BYTEPOS    EQU       0D
PERCENTPOS EQU       0B
uSPOS      EQU       09
SELCHPOS   EQU       0C
CVMPOS     EQU       0B
ONTIMEPOS  EQU       0B
CH53POS    EQU       08
CH50POS    EQU       0E
CH72POS    EQU       0D
CH50MHZPOS EQU       04
CH72MHZPOS EQU       04
TESTCHPOS  EQU       07
TESTVALPOS EQU       0C
TACHRPMPOS EQU       0B
RECVPOS    EQU       0B
endif

ifdef           ECMA1010display
LINE1     EQU        0B0
LINE2     EQU        0C0
LINE3     EQU        0D0
LINE4     EQU        0E0
CURSORON  EQU        03F
CURSOROFF EQU        031
YPOS      EQU        07
YNPOS     EQU        09
NPOS      EQU        0B
ACFTPOS    EQU       0A
BYTEPOS    EQU       09
PERCENTPOS EQU       07
uSPOS      EQU       05
SELCHPOS   EQU       08
CVMPOS     EQU       07
ONTIMEPOS  EQU       07
CH53POS    EQU       05
CH50POS    EQU       0B
CH72POS    EQU       0A
CH50MHZPOS EQU       03
CH72MHZPOS EQU       03
TESTCHPOS  EQU       05
TESTVALPOS EQU       08
TACHRPMPOS EQU       07  
RECVPOS    EQU       07
endif

; Button and signal definitions for the Transmitter controls
; PortA bits
BUZZER	EQU	4

; PortB bits
TACHIN	EQU	1
LED2	EQU	2
PLLRST	EQU	6		; PIC reset on RFDECK
SDObit	EQU	7		; Serial data out

; PortC bits
CFGMEM2	EQU	2
LED1	EQU	3
SDIbit	EQU	4
CLK	EQU	5		; Clock for PLL and config mem

; PortD bits
AilDR	EQU	0
EleDR	EQU	1
RudDR	EQU	2
PRESET	EQU	3
MIX1	EQU	4
MIX2	EQU	5
MIX3	EQU	6
CH5	EQU	7

; PortE bits
RUNCAL	EQU	0
AUTOT	EQU	1
OPTION	EQU	2
CH8A	EQU	3
CH8C	EQU	4
ALTAFK	EQU	5
SNAPR	EQU	6
SNAPL	EQU	7

; PortF bits
MOD	EQU	7

; PortG bits
CFGMEM1	EQU	0
PLLCS	EQU	3

; PortH bits
AUXOUT	EQU	0
TACHENA	EQU	1
RECCOMM	EQU	2

; LCD PORTS
LCDDATA		EQU	PORTJ
LCDDATADIR	EQU	DDRJ
LCDCTRL		EQU	PORTB
LCDCTRLDIR	EQU	DDRB

; ADC channel assignments
ADCch6		EQU	00
ADCch7		EQU	01
ADCgnd		EQU	02
ADCref		EQU	03
ADCail		EQU	04
ADCele		EQU	05
ADCrud		EQU	06
ADCthr		EQU	07
ADCailTrim	EQU	08
ADCeleTrim	EQU	09
ADCrudTrim	EQU	0A
ADCthrTrim	EQU	0B
ADCtest		EQU	0C
ADCrec		EQU	0D



;******* BANK0 variables
		ORG	0x00
;*******    INTERRUPT CONTEXT SAVE/RESTORE VARIABLES
TEMP_WREG       RES     1
TEMP_ALUSTA     RES     1
TEMP_BSR        RES     1
TEMP_PRODL      RES     1
TEMP_PRODH      RES     1
TEMP_WREG_L     RES     1
TEMP_ALUSTA_L   RES     1
TEMP_BSR_L      RES     1
TEMP_PRODL_L    RES     1
TEMP_PRODH_L    RES     1
Areg		RES	1	; General purpose registers
Breg		RES	1
Creg		RES	1
;
; Gereral variables
;
AXreg		RES	2	; 16 bit register
BXreg		RES	2	; 16 bit register
CXreg		RES	2	; 16 bit register
CEXreg		RES	4	; 32 bit regester
DEXreg		RES	4	; 32 bit regester
EEXreg		RES	4	; 32 bit regester
Atemp		RES	1
Btemp		RES	1
FSR1Lsave	RES	1
FSR1Hsave	RES	1
FPFLAGS		RES	1
SIGN		RES	1
Buffer		RES	D'10'
ISRtemp		RES	1	; Interrupt temp variable
PORTDimage	RES	1	; PortD debounced
PORTDlast	RES	1
PORTDlatch	RES	1
PORTEimage	RES	1	; PortE debounced
PORTElast	RES	1
PORTElatch	RES	1
;
Mode		RES	1	; Defines the system mode
modeRUN		EQU	1
modeCAL		EQU	2
Cmd		RES	1	; This flag is set by a host PC to
				; request an action. Valid commands are:
				; 	31 = Read general data from sprom
				;	32 = Read selected aircraft data from sprom
				;	33 = Write general data to sprom
				;	34 = Write selected aircraft data to sprom
; The following variables are used for the generation of the
; PPM output pulse train. All times are in .5uS units, 2MHz
; internal clock used by timer. Timer3 is used for this pulse
; generation.
CYCLECOUNTS	EQU	D'50000'; The number of timer counts in one 25 mS cycle
CHtimes		RES	D'20'	; One 16 bit word for each channel
				; 8 channels plus one checksum channel
;
; This table defines the transmitted channel order.
;
chELE	EQU	CHtimes+2
chAIL	EQU	CHtimes+4
chRUD	EQU	CHtimes+6
chTHT	EQU	CHtimes+8
chCH5	EQU	CHtimes+0A
chCH6	EQU	CHtimes+0C
chCH7	EQU	CHtimes+0E
chCH8	EQU	CHtimes+10
;

Pstate		RES	1	; State variable
NumChan		RES	1	; Number of transmit channels times two
NextTime	RES	2	; The timers next compare reg value
Psum		RES	2	; Total pulse time from start of output
Sync		RES	2	; Sync pulse width.
; The following variables are involved in time keeping
TICKSPER	EQU	D'40'	; Ticks per second
Cmode		RES	1	; Counter mode, 0 = count up, 1 = timer
Tick		RES	1	; Tick counter
Secs		RES	1	; Seconds sence reset
Mins		RES	1	; Minutes sence reset
Dsecs		RES	1	; Timer Seconds 
Dmins		RES	1	; Timer Minutes 
DsecsLatch	RES	1	; Timer Seconds 
BeepTicks	RES	1	; This is used to create a beep. The RTI will
				; turn off the buzzer after this many ticks
BeepCtr		RES	1	; Working counter...
BeepCyl		RES	1	; Number of cycles
TimeOut		RES	1	; This is a timeout counter. the RTI will dec this
				; if its not zero. Used by the serial rec routine
TimeOut1	RES	1	
TimeOut2	RES	1
; The following variables are used by USART1 serial receiver. Receive messages
; are in the following format:
;		1 byte, start of message = 0x55
;		1 byte, message type
;		1 byte, Bank address
;		1 byte, location
;		1 byte, data length
;		(optional data block if its a receive message)
;		1 byte, mod 256 checksum
; Valid message types are:
;	1 = Reveive message, from host
;	2 = Send message, to host
RECMESS		EQU	1
SENDMESS	EQU	2
ACK		EQU	D'12'
NAK		EQU	D'13'

MessState	RES	1	; defines the message receive state
MessStart	RES	1
MessType	RES	1
MessBank	RES	1
MessLoc		RES	1
MessLen		RES	1
MessCHK		RES	1
CheckSum	RES	1
; Generic channel work space
Pos		RES	2	; Pot position
Gh		RES	2	; High side gain
Ct		RES	2	; Center position
Gl		RES	2	; Low side gain
Npos		RES	2	; Normalized position
; Normalized channel positions, centering channels go -1000 to 1000
; and non centering channels go 0 to 1000
Apos		RES	2
Epos		RES	2
Rpos		RES	2
Tpos		RES	2
CH5pos		RES	2
CH6pos		RES	2
CH7pos		RES	2
CH8pos		RES	2
Atrim		RES	2
Etrim		RES	2
Rtrim		RES	2
Ttrim		RES	2
Vbat		RES	2
; Mixed channel positions
AposM		RES	2
EposM		RES	2
RposM		RES	2
TposM		RES	2
CH5posM		RES	2
CH6posM		RES	2
CH7posM		RES	2
CH8posM		RES	2
; More variables...
Ctemp		RES	1
Dtemp		RES	1
Etemp		RES	1
Ftemp		RES	1
TimeOut3	RES	1	; This timeer is used by the sync up function
TimeOut4	RES	1
TimeOut5	RES	1
TEMPB3		RES	1
DefaultAircraft	RES	1	; Default Aircraft number
SPROMAircraft	RES	2	; SPROM adress to start of current Aircraft data
MasterState	RES	1	; State variable used by the Buddy box system
MasterPos	RES	2	; Position variable
MApos		RES	2
MEpos		RES	2
MRpos		RES	2
MTpos		RES	2
Dst		RES	2	; Destination address
Src		RES	2	; Source address
Cnt		RES	1	; Number of bytes to move
DriveCh		RES	1	;
MinValue
MinTime
MinByte		RES	2
MaxValue
MaxTime
MaxByte		RES	2
OVERRUN		RES	1	; This flag is set if data is not updated
				; within one frame time
SymSet		RES	1	; This flag is set during the servo cal
				; function if the user wants to set the
				; channel symeterical about its center.
SWID		RES	2
BladeTime	RES	2	; Timer counts for aprox 1 sec worth of blade counts
BladeDet	RES	2	; Counts prop blade detections
AilCenter       RES     2       ; Ailron channel pot center position
EleCenter       RES     2       ; Elevator channel pot center position        
EnaSecSprom	RES	1	; This flag is set if a secondary Sprom is enabled
Usecs		RES	1	; Up counter seconds value
Umins		RES	1	; Up counter minutes value

TTflag		RES	1	; Flag set if in the Throttle trim adjust mode
; Variables used by the calibrate servos functions, and misc UI functions
EXIT		RES	1
DXreg  		RES	2
CalTable
SWselect
RTDWN		RES	2
CENTER		RES	2
LTUP		RES	2
DRP		RES	1
TRIMP		RES	1
ATRM		RES	1
EXPOHI		RES	1
EXPOLOW		RES	1
YESNO
ATRST		RES	1
STRIM
; Variables used by Mixer UI
Mfrom		RES	1
Mto		RES	1
Mzp		RES	1
Mpg		RES	1
Mng		RES	1
Mpi		RES	1
Mni		RES	1
Mreplace	RES	1
Mtbl		RES	1
AUXSTATE	RES	1	; State of AUXOUT signal.
SelSprom	RES	1	; Used by the Sprom Write functions the selected
				; devices Bit is set.      
TimerCount	RES	1	; This flag is set (FF) if the timer counting is 
				; Enabled. This flag is set in the TemerEnable 
				; Subroutine.
DPflag		RES	1	; Flag set to display a decimal point in the adjust
				; byte function
FMSflag		RES	1	; Flag set when in the FMS flight simulator mode

PostCall	RES	2	; Pointer to a post call function used by the UI functions
PreCall		RES	2	; Pointer to a pre call function used by the UI functions
FutabaStudent	RES	1	; This flag is set when in the Futaba stodent mode and the
				; the student button is pressed.
CalServoUpdate	RES	1	; The flag CalServoUpdate must be set or this function will
				; exit with no action.
IncTime		RES	1	; This value hold the number of ADC counts over threshold for 
				; use in the variable value increment time

;******* BANK1 variables
		ORG	0x100
; LMX2306 PLL setup parameters
; For the 50 MHz band
;       PDF     = 20
;       FCF     = 50800
;       FCN     = 0
;       NUMFREQ = 10
; For the 72 NHz band
;       PDF     = 10
;       FCF     = 72010
;       FCN     = 11
;       NUMFREQ = 60
Nreg		RES	3	; 21 bit register
Rreg		RES	3	; 21 Bit register
Freg		RES	3	; 20 bit register
PDF             RES     2       ; Phase detector frequency, in KHz
FCF             RES     3       ; First channel frequency, in KHz
FCN             RES     1       ; First channel number   
PMUL            RES     1       ; Phase clock multiplier
NUMFREQ         RES     1       ; Number of freq channel

; Misc variables
LValarm		RES	1	; Flag set after the low voltage alarm is given

; Temp data block, used to save data vars
TempBlock	RES	8	; 8 Bytes of storage

; Temp variables used for the Throttle Trim mode
TTBH		RES	2
TTMH		RES	2

; These variables are used by the User Interface routines
CalOption	RES	2
CalMenu		RES	2
CalMenu1	RES	2
CalMenu2	RES	2

PostCallLevel1	RES	2
PostCallLevel2	RES	2
PostCallLevel3	RES	2         

AXregS		RES	2
BXregS		RES	2
CXregS		RES	2
DXregS		RES	2
  
; Four main channels position information used for the trigger point switch routines
ATpos		RES	2
ETpos		RES	2
RTpos		RES	2
TTpos		RES	2

; Temp Alt Aircraft numbers
TAltA1		RES	1
TAltA2		RES	1

; Temporary storage for FSR1 reg set
SaveFSR1L	RES	1
SaveFSR1H	RES	1

;******* BANK2 variables
; 
; This area contains general setup parameters. This area is read from
; the serial prom on power up and these parameters apply to all aircraft.
; These parameters can not be reordered!
;
		ORG	0x200
Aircraft	RES	1	; Aircraft number 0 thru 7
; LMX2306 PLL setup parameters, R and F regs values
; for 50,53 and 72MHz bands
Rreg50		RES	3
Freg50		RES	3
Rreg53		RES	3
Freg53		RES	3
Rreg72		RES	3
Freg72		RES	3

; Voltage monitor gains, (Raw adc counts)* gain = millivolts
VmonG		RES	2	; Gain
; Joy stick calibration parameters. The gains are all times 256
; - first the centering sticks...
AHG		RES	2	; High side gain
ACT		RES	2	; Center counts
ALG		RES	2	; Low side gain

EHG		RES	2	; High side gain
ECT		RES	2	; Center counts
ELG		RES	2	; Low side gain

RHG		RES	2	; High side gain
RCT		RES	2	; Center counts
RLG		RES	2	; Low side gain
; The non centering sticks...
THG		RES	2	; High side gain
TCT		RES	2	; Center counts

AtrimHG		RES	2	; High side gain
AtrimCT		RES	2	; Center counts

EtrimHG		RES	2	; High side gain
EtrimCT		RES	2	; Center counts

RtrimHG		RES	2	; High side gain
RtrimCT		RES	2	; Center counts

TtrimHG		RES	2	; High side gain
TtrimCT		RES	2	; Center counts

CH6HG		RES	2	; High side gain
CH6CT		RES	2	; Center counts

CH7HG		RES	2	; High side gain
CH7CT		RES	2	; Center counts

		RES	3

; Translation tables
Table1		RES	D'11'
Table2		RES	D'11'
Table3		RES	D'11'
Table4		RES	D'11'
Table5		RES	D'11'
Table6		RES	D'11'
Table7		RES	D'11'
Table8		RES	D'11'

AutoTrimStep	RES	1	; Auto Trim step size
AutoTrimTime	RES	1	; Auto Trim adjust time in ticks

Student		RES	1	; This flag is set if this transmitter
				; will be used as a slave in the buddy box
				; system. 0 = clear, FF = set
Master		RES	1	; This flag is set if this transmitter will
				; be used as a master in the buddy box
				; system. 0 = clear, FF = set.
MaxChannels	RES	1	; Number of transmit channels
SyncWidth	RES	2	; Sync pulse width, in .5uS units
SelFreq		RES	1	; Selected frequency
				; 0FF = off
		RES	1	
Signature	RES	2	; This is a formatted signature, it must be A5 E7 or you
				; will be asked if you want to format the Sprom.
VRmonG		RES	2	; Gain for the receiver voltage monitor ADC channel
PLLinitWORD	RES	3	; This is the PLL initialization word, use to shut the
				; PLL down
ServoMin        RES     2       ; Servo minimum limit
ServoMax        RES     2       ; Servo maximum limit    

; Trim table. This table is used to define witch trim adjustment is used
; for each flight control.
; Valid values are:
;	0 = none
;	1 = Ail trim
;	2 = Ele trim
;	3 = Rud trim
;	4 = Tht trim
AilTrimCh	RES	1
EleTrimCh	RES	1
RudTrimCh	RES	1
ThtTrimCh	RES	1   

ATmode          RES     1       ; Auto trim mode, 0 = incremental, 1 = one shot
MasterMode	RES	1	; Master mode, 0 = MicroStar, 1 = Futaba

BTflag		RES	1	; This flag is set when its time to update the
				; battery timer value
BattAlarm	RES	1	; Battery alarm voltage level in .1 volt units
AUXMODE		RES	1	; Defines the channel to output on the
				; AUXOUT pin used for direct servo drive.
				; Setting the MSB defines the output to be
				; the encoded pulse train. To output a channel
				; set this variable to the channel number times
				; 2 plus 1.
; This is the ADC address table. This table is 16 bytes long and each byte selects
; the ADC multiplexer address and the ADC refrence. The reference is selected by the MSB 
; of each entery, 0 = external ref and 1 = 5 volt ref
ADCaddTbl		RES	16

; This is a flag byte used to define the frequency band for the RF deck. 
; Bit definitions:
;	Bit		Definition
;	0		Set for 50 MHz
;	1		Set for 53 MHz
; If both bits 0 and 1 are set then the 72 MHz band is selected
Fband			RES	1
; Buzzer polarity
BuzPol			RES	1	; 0 = normal sense, 0xFF = inverted
;******* BANK3 variables 
;
; This area contains aircraft specific setup parameters. The serial
; prom contains 8 total setup, the selected aircraft's parameters are
; copied into this block. These parameters can not be reordered!
;
		ORG	0x300
; Channel specfic data.
; Gereral data
Name		RES	D'16'	; Aircraft name for display!
Reserved	RES	1	; 
; Aielron
AM1H		RES	2	; Right gain
AB		RES	2	; Offset
AM2H		RES	2	; Left gain
ALR		RES	1	; Low rate, in percent
APT		RES	1	; Percent trim
AAT		RES	1	; Autotrim offset
AEXHI		RES	1	; Expo high rate percentage
AEXLOW		RES	1	; Expo low rate percentage
; Elevator
EM1H		RES	2	; Up gain
EB		RES	2	; Offset
EM2H		RES	2	; Down gain
ELR		RES	1	; Low rate, in percent
EPT		RES	1	; Percent trim
EAT		RES	1	; Autotrim offset
EEXHI		RES	1	; Expo high rate percentage
EEXLOW		RES	1	; Expo low rate percentage
; Rudder
RM1H		RES	2	; Right gain
RB		RES	2	; Offset
RM2H		RES	2	; Left
RLR		RES	1	; Low rate, in percent
RPT		RES	1	; Percent trim
RAT		RES	1	; Autotrim offset
REXHI		RES	1	; Expo high rate percentage
REXLOW		RES	1	; Expo low rate percentage
; Throttle
TMH		RES	2	; Gain and offset
TBH		RES	2
TPT		RES	1	; Percent trim
TMODE		RES	1	; Trim mode
Tpreset		RES	2	; Preset servo position
; CH5, retract
CH5MH		RES	2
CH5BH		RES	2
; CH6
CH6MH		RES	2	; Gain and offset
CH6BH		RES	2
; CH7
CH7MH		RES	2	; Gain and offset
CH7BH		RES	2
; CH8, three position, A,B,C
CH8_A		RES	2
CH8_B		RES	2
CH8_C		RES	2
; Snap right
SR_A		RES	2
SR_E		RES	2
SR_R		RES	2
SR_T		RES	2
; Snap left
SL_A		RES	2
SL_E		RES	2
SL_R		RES	2
SL_T		RES	2
; Mixers, 3 total
; 1
M1Afrom		RES	1
M1Ato		RES	1
M1Azp		RES	1
M1Aur		RES	1
M1Adl		RES	1
M1Bfrom		RES	1
M1Bto		RES	1
M1Bzp		RES	1
M1Bur		RES	1
M1Bdl		RES	1
M1Cfrom		RES	1
M1Cto		RES	1
M1Czp		RES	1
M1Cur		RES	1
M1Cdl		RES	1
M1Dfrom		RES	1
M1Dto		RES	1
M1Dzp		RES	1
M1Dur		RES	1
M1Ddl		RES	1
; 2
M2Afrom		RES	1
M2Ato		RES	1
M2Azp		RES	1
M2Aur		RES	1
M2Adl		RES	1
M2Bfrom		RES	1
M2Bto		RES	1
M2Bzp		RES	1
M2Bur		RES	1
M2Bdl		RES	1
M2Cfrom		RES	1
M2Cto		RES	1
M2Czp		RES	1
M2Cur		RES	1
M2Cdl		RES	1
M2Dfrom		RES	1
M2Dto		RES	1
M2Dzp		RES	1
M2Dur		RES	1
M2Ddl		RES	1
; 3
M3Afrom		RES	1
M3Ato		RES	1
M3Azp		RES	1
M3Aur		RES	1
M3Adl		RES	1
M3Bfrom		RES	1
M3Bto		RES	1
M3Bzp		RES	1
M3Bur		RES	1
M3Bdl		RES	1
M3Cfrom		RES	1
M3Cto		RES	1
M3Czp		RES	1
M3Cur		RES	1
M3Cdl		RES	1
M3Dfrom		RES	1
M3Dto		RES	1
M3Dzp		RES	1
M3Dur		RES	1
M3Ddl		RES	1
; Fixed mix functions.
VTAIL		RES	1	; 0=off and FF=on
ELEVON		RES	1	; 0=off and FF=on
DUALA		RES	1	; 0=off and FF=on
REVA		RES	1	; 0=nornal, FF=channel 7 reverse
DIFFA		RES	1	; Percentage of differential, 0 = off
FPgain		RES	1	; Amount of flaps, 0 = off
THOLD		RES	1	; Throttle hold flag, FF = On
THOLDp		RES	1	; Throttle hold percentage
IDLEUP		RES	1	; Idle up flag, FF = On
IDLEUPpA	RES	1	; Idle up percentage A
IDLEUPpB	RES	1	; Idle up percentage B
		RES	1	
FixedFirst	RES	1	; If this flag is set (FF) then the fixed mixer
				; functions are completed before the general mixers.
NumBlades	RES	1	; Number of prop blades, used by Tach
RetractsWarning	RES	1	; This flag is set if you want a retracts up warning

; The following variables hold the trim zero values. These variables are used to recenter
; the trims. 

TrimZeroAil	RES	2
TrimZeroEle	RES	2
TrimZeroRud	RES	2

ModelChannel	RES	1	; This models fraquency channel

; Switch selections
SWAILDR		RES	1
SWELEDR		RES	1
SWRUDDR		RES	1
SWPRESET	RES	1
SWMIX1		RES	1
SWMIX2		RES	1
SWMIX3		RES	1
SWCH5		RES	1
SWATRIM		RES	1
SWCH8A		RES	1
SWCH8B		RES	1
SWCH8C		RES	1
		RES	1
SWSNAPR		RES	1
SWSNAPL		RES	1 

; Timer variables...
CNTmode		RES	1	; 0 = On time only, 1 = DWN timer
DWNSecs		RES	1
DWNMins		RES	1
TEnaSW		RES	1	; Switch used to enable timer
Tthres		RES	1	; Throttle threshold for timer

; More switch selections
SWTHOLD		RES	1
SWIDLEUP1	RES	1
SWIDLEUP2	RES	1

; Additions for the CROW function
SWCROW          RES     1       ; The Crow switch, by default is Mixer 1 switch
CROWENA         RES     1       ; Flag set if CROW is enabled.

		RES	1	
		RES	1	

; Control stick trigger positions
ATP		RES	1
ETP		RES	1
RTP		RES	1
TTP		RES	1

SHIFT		RES	1	; Set to FF for ACE shift

; Alternate aircraft array, 6 entries, each entry is:
;   First byte =  Switch ID
;   Second byte = Aircraft number
NumAlt		EQU	6
AltAircraft	RES	2 * 6

; Aircraft specific translation tables
Atable1		RES	D'11'
Atable2		RES	D'11'

;******* BANK4 variables 
;
; This page holds the second 256 byte page of the aircraft specific memory
;
		ORG	0x400
; Output order. This table defines the output channel order. The user can
; configure any order he likes. You can even repeat the same channel if
; required for your application
ChannelOrder	RES	8
; The following table supports subtrims. This allows the pilot to set the servo 
; center position of any cannel independently
SubTrim		RES	8
; The following variables support additional fixed mixers that are commonly 
; used by pilots
;			- Ail to rudder, 2 bytes
;			- Rud to ail, 2 bytes
;			- Rud to ele, 2 bytes
;			- Throttle to ele, 1 byte
;			- Dual elevator, 2 bytes
AilRudPos	RES	1
AilRudNeg	RES	1

RudAilPos	RES	1
RudAilNeg	RES	1

RudElePos	RES	1
RudEleNeg	RES	1

ThtEle		RES	1

DualE		RES	1	; Flag, 0=off, FF=on
RevE		RES	1	; Reverse second Elevator channel (Channel 6)


;******* BANK5 variables 
;
; This area is backed up in EEPROM memory
;
		ORG	0x500
BatteryTimer	RES	2	; This variable holds the total "on" time of the
				; transmitter. This value is saved in the EEPROM.
				

;
; This page holds a copy of the primary aircraft setup variables. This data is used by
; the alternate aircraft function. The switch data held in this area is used to contol
; the selection.
;
		ORG	0x600
Backup		RES	D'256'

;
; This page holds the second backup 256 byte page of aircraft setup variables.
;
		ORG	0x700

;
; This page is used for the save aircraft name function
;
		ORG	0x800

;*******    MACROS
GOTOF		MACRO	ADDRS
		GOTO	ADDRS
		ENDM

CALLF		MACRO 	ADDRS
		CALL	(ADDRS)
		ENDM

CALLFL		MACRO 	ADDRS,VAL
		MOVLW	(VAL)
		CALL	(ADDRS)
		ENDM

CALLFW		MACRO 	ADDRS
		CALL	(ADDRS)
		ENDM

CALLFF		MACRO 	ADDRS,VAL
		MOVFP	(VAL),WREG
		CALL	(ADDRS)
		ENDM

PUSHREGS        MACRO                 ;macro for saving registers, used in high priority ISRs
            	MOVFF   ALUSTA,TEMP_ALUSTA
            	MOVFF   BSR,TEMP_BSR
            	MOVWF   TEMP_WREG
		MOVFF	PRODL, TEMP_PRODL
		MOVFF	PRODH, TEMP_PRODH
            	ENDM

POPREGS         MACRO                 ;macro for restoring registers, used in high priority ISRs
		MOVFF	TEMP_PRODL, PRODL
		MOVFF	TEMP_PRODH, PRODH
            	MOVF    TEMP_WREG,W
            	MOVFF   TEMP_BSR,BSR
            	MOVFF   TEMP_ALUSTA,ALUSTA
            	ENDM

PUSHREGSLOW     MACRO                 ;macro for saving registers, used in low priority ISRs
            	MOVFF   ALUSTA,TEMP_ALUSTA_L
            	MOVFF   WREG,TEMP_WREG_L
            	MOVFF   BSR,TEMP_BSR_L
		MOVFF	PRODL, TEMP_PRODL_L
		MOVFF	PRODH, TEMP_PRODH_L
            	ENDM


POPREGSLOW      MACRO                 ;macro for restoring registers, used in low priority ISRs
		MOVFF	TEMP_PRODL_L, PRODL
		MOVFF	TEMP_PRODH_L, PRODH
            	MOVFF   TEMP_BSR_L,BSR
            	MOVFF   TEMP_WREG_L,WREG
            	MOVFF   TEMP_ALUSTA_L,ALUSTA
            	ENDM

PrintMess   	MACRO   MESSAGE
		MOVLW	UPPER (MESSAGE)
		MOVWF	TBLPTRU,A
		MOVLW	HIGH (MESSAGE)
		MOVWF	TBLPTRH,A
		MOVLW	LOW (MESSAGE)
		MOVWF	TBLPTRL,A
		CALLF	LCDsendMess
	    	ENDM

PrintMessN   	MACRO   MESSAGE
		MOVLW	UPPER (MESSAGE)
		MOVWF	TBLPTRU,A
		MOVLW	HIGH (MESSAGE)
		MOVWF	TBLPTRH,A
		MOVLW	LOW (MESSAGE)
		MOVWF	TBLPTRL,A
		CALLF	LCDsendMessN
	    	ENDM

; This macro set the carry flag if the port's bit is set
State		MACRO	PORT,BIT
		MOVLB	HIGH PORT
		BCF	ALUSTA,C
		BTFSC	PORT,BIT
		BSF	ALUSTA,C
		ENDM

; Carry flag is cleared if the button is pressed and remains pressed
; 10 mSec later
Pressed		MACRO	PORT,BIT
		State	PORT,BIT
		BTFSC	ALUSTA,C
		GOTO	$ + D'14'
		MOVLW	D'10'
		CALL	Delay1mS
		State	PORT,BIT
		ENDM

; Waits for a button to be released and stay released for 10 mSec
Release		MACRO	PORT,BIT
		State	PORT,BIT
		BTFSS	ALUSTA,C
		GOTO	$ - D'10'
		MOVLW	D'10'
		CALL	Delay1mS
		State	PORT,BIT
		BTFSS	ALUSTA,C
		GOTO	$ - D'30'
		ENDM

MOVEB		MACRO	REG1,REG2
		MOVFF	REG1,REG2
		ENDM
		
MOVE16		MACRO	REG1,REG2
		MOVFF	REG1,REG2
		MOVFF	REG1+1,REG2+1
		ENDM
		
MOVE		MACRO	REG1,REG2
		MOVFF	REG1,REG2
		MOVFF	REG1+1,REG2+1
		ENDM

MOVE24		MACRO	REG1,REG2
		MOVFF	REG1,REG2
		MOVFF	REG1+1,REG2+1
		MOVFF	REG1+2,REG2+2
		ENDM
		
MOVEC		MACRO	CONST,REG
		MOVLR	HIGH (REG)
		MOVLW	LOW (CONST)
		MOVWF	(REG)
		MOVLW	HIGH (CONST)
		MOVWF	(REG+1)
		ENDM     
		
MOVEC24		MACRO	CONST,REG
		MOVLR	HIGH (REG)
		MOVLW	LOW (CONST)
		MOVWF	(REG)
		MOVLW	LOW (CONST/100)
		MOVWF	(REG+1)
		MOVLW	HIGH (CONST/100)
		MOVWF	(REG+2)
		ENDM

; The following macros support indirect word movements

        ; Move from address to word
MOVEIW          MACRO   ADD,REG
                MOVLW   0F
                ANDWF   BSR,F
                MOVLR   HIGH ADD
                MOVFP   ADD,FSR1
                MOVFP   ADD+1,WREG
                SWAPF   WREG
                IORWF   BSR,F
                BCF     ALUSTA,FS3
                BSF     ALUSTA,FS2
                MOVPF   INDF1,REG
                MOVPF   INDF1,REG+1
                ENDM
                
        ; Move from word to address
MOVEWI          MACRO   REG,ADD
                MACRO   ADD,REG
                MOVLW   0F
                ANDWF   BSR,F
                MOVLR   HIGH ADD
                MOVFP   ADD,FSR1
                MOVFP   ADD+1,WREG
                SWAPF   WREG
                IORWF   BSR,F
                BCF     ALUSTA,FS3
                BSF     ALUSTA,FS2
                MOVFP   REG,INDF1
                MOVFP   REG+1,INDF1
                ENDM  
                
        ; Move from address to byte
MOVEIB          MACRO   ADD,REG
                MOVLW   0F
                ANDWF   BSR,F
                MOVLR   HIGH ADD
                MOVFP   ADD,FSR1
                MOVFP   ADD+1,WREG
                SWAPF   WREG
                IORWF   BSR,F
                MOVPF   INDF1,WREG
                MOVLR	HIGH REG
                MOVWF	REG
                ENDM
                
        ; Move from byte to address
MOVEBI          MACRO   REG,ADD
		MOVLR	HIGH REG
		MOVFP	REG,PRODH
                MOVLW   0F
                ANDWF   BSR,F
                MOVLR   HIGH ADD
                MOVFP   ADD,FSR1
                MOVFP   ADD+1,WREG
                SWAPF   WREG
                IORWF   BSR,F
                MOVFP   PRODH,INDF1
                ENDM
;**********************************************************************
                ORG    0x000 + OFFSET
                goto   start	


;************   High Priority INTERRUPT VECTOR
                ORG    		0x008 + OFFSET
		GOTO		HIGHISRS

;************   Low Priority INTERRUPT VECTOR
                ORG		0x018 + OFFSET
		GOTO		LOWISRS


HIGHISRS
           	PUSHREGS              		;save specific registers
        ; Test if this is a hardware interrupt 1. This is used for the tach and 
        ; the futaba trainer system
        	BTFSS	INTCON3,INT1IP,A	; If INT1 is set to low priority then do not test
        	GOTO	HIGHISRS0		; if its active
        	BTFSC	INTCON3,INT1IF,A
;		GOTO	HIGHISRS0
        	CALL	INT1ISR
;		POPREGS
;            	retfie
	; Test if this is a timer3 interrupt, compare reg 2
HIGHISRS0   	BTFSS	IPR2,CCP2IP,A		; If Timer3 is set to low priority then do not test
        	GOTO	HIGHISRS1		; if its active
		BTFSC	PIR2,CCP2IF,A
		CALL	TIMER3ISR
	; Exit
HIGHISRS1   	POPREGS               		;restore specific registers
            	retfie            		;return from interrupt
               

LOWISRS
            	PUSHREGSLOW            		;save specific registers
        ; Test if this is a hardware interrupt 1. This is used for the tach and 
        ; the futaba trainer system
        	BTFSC	INTCON3,INT1IP,A	; If INT1 is set to high priority then do not test
        	GOTO	LOWISRS0		; if its active
        	BTFSC	INTCON3,INT1IF,A
        	CALL	INT1ISR
	; Test if this is a timer3 interrupt
LOWISRS0    	BTFSC	IPR2,CCP2IP,A		; If Timer3 is set to high priority then do not test
        	GOTO	LOWISRS1		; if its active
		BTFSC	PIR2,CCP2IF,A
		CALL	TIMER3ISR
	; Test for COMM port interrupts, call service routine if active
LOWISRS1	
	; If Timer3 ISR is low priority then don't call the USART functions.
	; Read the USARTS and exit.
		BTFSC	IPR2,CCP2IP,A
		GOTO	LOWISR2
		MOVFF	RCREG1,WREG
		MOVFF	RCREG2,WREG
		GOTO	LOWISR3
	; Here to process the USARTS
LOWISR2
		BTFSC	PIR1,RC1IF,A
		CALL	USART1rec
		BTFSC	PIR3,RC2IF,A
		CALL	SendStudent
	; Exit	
LOWISR3
		POPREGSLOW             		;restore specific registers
            	retfie            		;return from interrupt


		ORG	100 + OFFSET


; Jump tables all Call tables.....
; These tables must not be moved...
; Calibration options...
CALoptions
		MOVF	PCL,W,A		; Refresh the latch regs
		MOVLB	HIGH CXreg
		MOVF	CXreg,W
		ADDWF	PCL
		GOTO	CalSelectAircraft
		GOTO	CalAircraftName
		GOTO	CalTimer
		GOTO	CalSnap
		GOTO	CalServos
		GOTO	CalMixers
		GOTO	CalSwitch
		GOTO	CalOptions
		GOTO	CalSharedOptions
		GOTO	CalSystemSetup
		GOTO	CalSelectFrequency
		RETURN 					; Exit option
		
; This function will load BXreg with the trim value indexed by WREG
; WREG              
;	0 = Set to 0, no trim
;	1 = Aileron
;	2 = Elevator
;	3 = Rudder
;	4 = Throttle 
SelectTrim        
		IORLW	0
		BTFSS	ALUSTA,Z
		GOTO	ST1
		MOVEC	0,BXreg
		RETURN
ST1              
	; Build index
		DECF	WREG
		ANDLW	3
		MULLW	D'10'
		MOVFF	PCL,WREG		; Refresh the program counter latch
		MOVFP	PRODL,WREG
		ADDWF	PCL
		; Aileron 
		MOVE	Atrim,BXreg
		RETURN
		; Elevator
		MOVE	Etrim,BXreg
		RETURN
		; Rudder
		MOVE	Rtrim,BXreg
		RETURN
		; Throttle
		MOVE	Ttrim,BXreg
		RETURN   

		ORG	200 + OFFSET
                      
; This function returns the selected channel. WREG is the index into
; the ChannelOrder table. The indexed value is moved into NextTime. 
; Reg INDF0 contains the index value                     
SelectOutputChannel
 	; Build index
		MOVFF	INDF0,WREG
		DECF	WREG
		ANDLW	7
		MULLW	D'10'
		MOVFF	PCL,WREG		; Refresh the program counter latch
		MOVF	PRODL,W,A
		ADDWF	PCL	

               ; Aileron
                MOVE16	chAIL,NextTime
		RETURN
                ; Elevator
                MOVE16	chELE,NextTime
		RETURN
                ; Rudder
                MOVE16	chRUD,NextTime
		RETURN
                ; Throttle
                MOVE16	chTHT,NextTime
		RETURN
                ; CH5
                MOVE16	chCH5,NextTime
		RETURN
                ; CH6
                MOVE16	chCH6,NextTime
		RETURN
                ; CH7
                MOVE16	chCH7,NextTime
		RETURN
                ; CH8
                MOVE16	chCH8,NextTime
		RETURN
		
; This function will load the ADC mux byte from the ADCaddTbl table located
; in the general data area, page 2.
; On call WREG contains the ADC channel request and on return the data is in 
; WREG.
ADClookup
   ; Compute the jump location
		ANDLW	0F
		MULLW	6
		MOVFF	PCL,WREG		; Refresh the program counter latch
		MOVF	PRODL,W,A
		ADDWF	PCL	

		MOVFF	ADCaddTbl, WREG
		RETURN
		MOVFF	ADCaddTbl+1, WREG
		RETURN
		MOVFF	ADCaddTbl+2, WREG
		RETURN
		MOVFF	ADCaddTbl+3, WREG
		RETURN
		MOVFF	ADCaddTbl+4, WREG
		RETURN
		MOVFF	ADCaddTbl+5, WREG
		RETURN
		MOVFF	ADCaddTbl+6, WREG
		RETURN
		MOVFF	ADCaddTbl+7, WREG
		RETURN
		MOVFF	ADCaddTbl+8, WREG
		RETURN
		MOVFF	ADCaddTbl+9, WREG
		RETURN
		MOVFF	ADCaddTbl+0A, WREG
		RETURN
		MOVFF	ADCaddTbl+0B, WREG
		RETURN
		MOVFF	ADCaddTbl+0C, WREG
		RETURN
		MOVFF	ADCaddTbl+0D, WREG
		RETURN
		MOVFF	ADCaddTbl+0E, WREG
		RETURN
		MOVFF	ADCaddTbl+0F, WREG
		RETURN

		ORG	300+OFFSET

; This function will return the channel number in reg AXreg. The
; channel number must be in WREG the channels are numbered 1 to 8.
; The position data is read from the mixed position array.
GetFrom
		MOVLB	HIGH AposM
		DECF	WREG
		ANDLW	7
		MULLW	D'10'
		MOVFF	PCL,WREG		; Refresh the program counter latch
		MOVF	PRODL,W,A
		ADDWF	PCL	
	; Channel 1
		MOVF	AposM,W
		MOVWF	AXreg
		MOVF	AposM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 2
		MOVF	EposM,W
		MOVWF	AXreg
		MOVF	EposM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 3
		MOVF	RposM,W
		MOVWF	AXreg
		MOVF	RposM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 4
		MOVF	TposM,W
		MOVWF	AXreg
		MOVF	TposM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 5
		MOVF	CH5posM,W
		MOVWF	AXreg
		MOVF	CH5posM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 6
		MOVF	CH6posM,W
		MOVWF	AXreg
		MOVF	CH6posM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 7
		MOVF	CH7posM,W
		MOVWF	AXreg
		MOVF	CH7posM+1,W
		MOVWF	AXreg+1
		RETURN
	; Channel 8
		MOVF	CH8posM,W
		MOVWF	AXreg
		MOVF	CH8posM+1,W
		MOVWF	AXreg+1
		RETURN

		ORG	400+OFFSET

; This function will sum the value in AXreg with the channel number defined
; in the WREG. This sum is performed on the position variable array. If the
; MSB is set then the value is AXreg replaces the old position value, if the
; MSB is clear then AXreg is added to the position value
ApplyMix
		MOVLB	HIGH Apos
		BTFSC	WREG,7
		GOTO	ApplyMixReplace
		DECF	WREG
		ANDLW	7
		MULLW	D'10'
		MOVFF	PCL,WREG		; Refresh the program counter latch
		MOVF	PRODL,W,A
		ADDWF	PCL	
	; Channel 1
		MOVF	AXreg,W
		ADDWF	Apos,F
		MOVF	AXreg+1,W
		ADDWFC	Apos+1,F
		RETURN
	; Channel 2
		MOVF	AXreg,W
		ADDWF	Epos,F
		MOVF	AXreg+1,W
		ADDWFC	Epos+1,F
		RETURN
	; Channel 3
		MOVF	AXreg,W
		ADDWF	Rpos,F
		MOVF	AXreg+1,W
		ADDWFC	Rpos+1,F
		RETURN
	; Channel 4
		MOVF	AXreg,W
		ADDWF	Tpos,F
		MOVF	AXreg+1,W
		ADDWFC	Tpos+1,F
		RETURN
	; Channel 5
		MOVF	AXreg,W
		ADDWF	CH5pos,F
		MOVF	AXreg+1,W
		ADDWFC	CH5pos+1,F
		RETURN
	; Channel 6
		MOVF	AXreg,W
		ADDWF	CH6pos,F
		MOVF	AXreg+1,W
		ADDWFC	CH6pos+1,F
		RETURN
	; Channel 7
		MOVF	AXreg,W
		ADDWF	CH7pos,F
		MOVF	AXreg+1,W
		ADDWFC	CH7pos+1,F
		RETURN
	; Channel 8
		MOVF	AXreg,W
		ADDWF	CH8pos,F
		MOVF	AXreg+1,W
		ADDWFC	CH8pos+1,F
		RETURN
ApplyMixReplace
		DECF	WREG
		ANDLW	7
		MULLW	D'10'
		MOVFF	PCL,WREG		; Refresh the program counter latch
		MOVF	PRODL,W,A
		ADDWF	PCL	
	; Channel 1
		MOVF	AXreg,W
		MOVWF	Apos
		MOVF	AXreg+1,W
		MOVWF	Apos+1
		RETURN
	; Channel 2
		MOVF	AXreg,W
		MOVWF	Epos
		MOVF	AXreg+1,W
		MOVWF	Epos+1
		RETURN
	; Channel 3
		MOVF	AXreg,W
		MOVWF	Rpos
		MOVF	AXreg+1,W
		MOVWF	Rpos+1
		RETURN
	; Channel 4
		MOVF	AXreg,W
		MOVWF	Tpos
		MOVF	AXreg+1,W
		MOVWF	Tpos+1
		RETURN
	; Channel 5
		MOVF	AXreg,W
		MOVWF	CH5pos
		MOVF	AXreg+1,W
		MOVWF	CH5pos+1
		RETURN
	; Channel 6
		MOVF	AXreg,W
		MOVWF	CH6pos
		MOVF	AXreg+1,W
		MOVWF	CH6pos+1
		RETURN
	; Channel 7
		MOVF	AXreg,W
		MOVWF	CH7pos
		MOVF	AXreg+1,W
		MOVWF	CH7pos+1
		RETURN
	; Channel 8
		MOVF	AXreg,W
		MOVWF	CH8pos
		MOVF	AXreg+1,W
		MOVWF	CH8pos+1
		RETURN
	
; This function will return after the PPM transmission has just completed.
; If the interrupts are not enabled this function will return without
; any delay.
SyncUp
   ; Test interrupts and return if disabled
		BTFSS	INTCON,GIE
		RETURN
   ; Set time out counter 3 to 1 and wait for it to reach 0
		MOVLB	HIGH TimeOut3
		MOVLW	1
		MOVWF	TimeOut3
SyncUp1                              
 		TSTFSZ	TimeOut3
		GOTO	SyncUp1
		RETURN
;************************************************************************
;************************************************************************
;*****	MAIN PROGRAM  *****
;************************************************************************
;************************************************************************
start
	; kill the buzzer
ifdef		ADAPTER
		BCF	DDRA,BUZZER,A		; If its an adapter, assume normal buzzer
		BCF	PORTA,BUZZER,A 
else
		BSF	DDRA,BUZZER,A		; Set control pin as input to disable
						; Iniit the port after config is loaded
endif
		BCF	DDRB,PLLRST,A
		BCF	PORTB,PLLRST,A
		MOVLB	HIGH BeepTicks
		CLRF	BeepTicks
		CLRF	BeepCtr
	; Clear counter mode
		MOVLB	HIGH Cmode
		CLRF	Cmode	
	; 100 mS startup delay to let all systems stabilize
		MOVLW	D'100'
		CALL Delay1mS
	; Init the port variables
		MOVLB	HIGH PORTD
		MOVF	PORTD,W
		MOVWF	PORTDimage
		MOVWF	PORTDlast
		MOVWF	PORTDlatch
		MOVLB	HIGH PORTE
		MOVF	PORTE,W
		MOVWF	PORTEimage
		MOVWF	PORTElast
		MOVWF	PORTElatch
		MOVLB	HIGH PORTH
		BCF	DDRH,AUXOUT
		BSF	PORTH,AUXOUT		; by default output the ppm pulse train
		BCF	DDRC,LED1  
		BCF	DDRB,LED2  
		BCF	PORTC,LED1  
		BCF	PORTB,LED2  
	; Init math variables
		MOVEC	0,DEXreg
		MOVEC	0,DEXreg+2
		MOVEC	0,EEXreg
		MOVEC	0,EEXreg+2
		MOVEC	0,CEXreg
		MOVEC	0,CEXreg+2
	; Init misc variables
		MOVEC	0,MApos
		MOVEC	0,MEpos
		MOVEC	0,MRpos
		MOVEC	0,MTpos
		MOVLB	HIGH TimeOut
		CLRF	TimeOut
		CLRF	TimeOut1
		CLRF	TimeOut2
		CLRF	TimeOut3
		CLRF	TimeOut4
		CLRF	TimeOut5   
		SETF	TimerCount
		CLRF	FMSflag
		MOVLB	HIGH AUXMODE
		CLRF	AUXMODE
		MOVLB	HIGH LValarm
		CLRF	LValarm
		MOVLB	HIGH TTflag
		CLRF	TTflag
	; Load the defaults
		CALL	LoadDefaults
		; Set DefaultAircraft equal to Aircraft
		MOVLB	HIGH Aircraft
		MOVF	Aircraft,W
		MOVLB	HIGH DefaultAircraft
		MOVWF	DefaultAircraft
	; Read the stick center positions
	        MOVLW   ADCail
	        CALL    ADCread
	        MOVLW   ADCail
	        CALL    ADCread
	        MOVLB   HIGH AilCenter
	        MOVF    ADRESL,W,A
	        MOVWF   AilCenter
	        MOVF    ADRESH,W,A
	        MOVWF   AilCenter+1
	        MOVLW   ADCele
	        CALL    ADCread
	        MOVLW   ADCele
	        CALL    ADCread
	        MOVLB   HIGH EleCenter
	        MOVF    ADRESL,W,A
	        MOVWF   EleCenter
	        MOVF   	ADRESH,W,A
	        MOVWF   EleCenter+1
	; Read the BatteryTimer value from EEPROM
		MOVLW	LOW BatteryTimer
		MOVFF	WREG,AXreg
		CLRF	WREG,A
		MOVFF	WREG,AXreg+1
		CALL	EEPROMreadByte
		MOVFF	WREG,BatteryTimer
		MOVLW	LOW BatteryTimer+1
		MOVFF	WREG,AXreg
		CLRF	WREG,A
		MOVFF	WREG,AXreg+1
		CALL	EEPROMreadByte
		MOVFF	WREG,BatteryTimer+1
	; Signon message
		CALL	LCDinit
		MOVLW	D'250'
		CALL 	Delay1mS
		MOVLW	D'250'
		CALL 	Delay1mS
		MOVLW	D'250'
		CALL 	Delay1mS
		MOVLW	D'250'
		CALL 	Delay1mS
	; Perform initializations...
		CALL	Timer3Init
		CALL	TachInit
		CALL 	USART1init
		CALL 	USART2init
	; Enable global interrups...
		BSF	INTCON,GIE
		BSF	INTCON,PEIE
		BSF	RCON,IPEN
	; Read the Flash general data into bank 2
		; If the PRESET and the AUTOTRIM button are pressed, then bypass...
		Pressed PORTD,PRESET
		BTFSC	ALUSTA,C
		GOTO	UseGeneral
		Pressed PORTE,AUTOT
		BTFSS	ALUSTA,C
		GOTO	UseDefaults
		; Read the gereral aircraft data...
UseGeneral
		CALL	LoadGeneral
		; Test the Signature, if its not valid call FormatFlash
		MOVLB	HIGH Signature
		MOVLW	0A5
		CPFSEQ	Signature
		GOTO	FormatIt
		MOVLW	0E7
		CPFSEQ	Signature+1
		GOTO	FormatIt
		GOTO	FormatOK
FormatIt
		CALL	LoadDefaults
		CALL	FormatFlash
FormatOK
		; Read this aircraft...into bank 3
		MOVFF	Aircraft,WREG
		CALL	LoadAircraft
		; Move ModelChannel to SelFreq
		MOVLB	HIGH ModelChannel
		MOVF	ModelChannel,W
		MOVLB	HIGH SelFreq
		MOVWF	SelFreq
	; Init the PLL and turn the RF off
		CALL	PLLinit    
		CALL	PLLCalNreg
		; Set the LSB of Freg to F2 to turn off the RF
		MOVLB	HIGH Freg
		MOVLW	0F2
		MOVWF	Freg
		CALL	PLLsetup	
UseDefaults
	; Make sure the AUTOTRIM button is released before
	; we continue...
		Release PORTE,AUTOT
	; Init the buzzer and turn it off
ifdef		ADAPTER
		BSF	PORTA,BUZZER,A 
else
		BCF	PORTA,BUZZER,A 
endif
		MOVFF	BuzPol,WREG
		TSTFSZ	WREG
		GOTO	BuzInited
ifdef		ADAPTER
		BCF	PORTA,BUZZER,A 
else
		BSF	PORTA,BUZZER,A 
endif
BuzInited:
		BCF	DDRA,BUZZER,A		; Set control pin as ouput	
	; Reestablish the stick center positions
	        MOVLW   ADCail
	        CALL    ADCread
	        MOVLW   ADCail
	        CALL    ADCread
	        MOVLB   HIGH AilCenter
	        MOVF    ADRESL,W,A
	        MOVWF   AilCenter
	        MOVF    ADRESH,W,A
	        MOVWF   AilCenter+1
	        MOVLW   ADCele
	        CALL    ADCread
	        MOVLW   ADCele
	        CALL    ADCread
	        MOVLB   HIGH EleCenter
	        MOVF    ADRESL,W,A
	        MOVWF   EleCenter
	        MOVF   	ADRESH,W,A
	        MOVWF   EleCenter+1
	; Test if the option button and the preset button are pressed
	; If they are both pressed then enter the IO test routine
		Pressed	PORTE,OPTION
		BTFSC	ALUSTA,C
		GOTO	mainStartup
		Pressed	PORTD,PRESET
		BTFSS	ALUSTA,C
		GOTO	TestIO
mainStartup
		; If student mode turn off RF
		MOVLB	HIGH Student
		MOVFF	Student,Areg
		MOVLB	HIGH SelFreq
		MOVLW	0FF
		BTFSC	Areg,0
		MOVWF	SelFreq
		CPFSLT	SelFreq
		GOTO	Startup1
	; If Retracks up warning is enabled and the retracts are up,
	; issue a warning to the pilot
		MOVLB	HIGH RetractsWarning
		BTFSS	RetractsWarning,0
		GOTO	NoRetractWarn
		MOVLB	HIGH PORTD
		BTFSC	PORTD,CH5
		GOTO	NoRetractWarn
		; If here warn the pilot before the RF goes on!
		MOVLW	LINE1
		CALL	LCDsendCMD
		PrintMess MES16
		MOVLW	LINE2
		CALL	LCDsendCMD
		PrintMess MES8
NRWwfo
		Pressed	PORTE,OPTION
		BTFSC	ALUSTA,C
		GOTO	NRWwfo
		Release	PORTE,OPTION
		MOVLW	D'200'
		CALL	Delay1mS
NoRetractWarn
	; If Fband = 0 then no RF deck to control
		MOVLB	HIGH Fband
		BTFSC	Fband,0
		GOTO	RFask
		BTFSS	Fband,1
		GOTO	Startup1
	; Display the Freq and ask pilot
RFask
		MOVLW	LINE1
		MOVLB	HIGH Ctemp
		MOVWF	Ctemp
		CALL	DisplayFrequency
		BCF	ALUSTA,C
		CALL	Accept
		; If no, set SelFreq=FF else turn on rf
		BTFSC	ALUSTA,C
		GOTO	Startup2
		; Here to leave rf off
		MOVLB	HIGH SelFreq
		MOVLW	0FF
		MOVWF	SelFreq
		GOTO	Startup1
Startup2	; Here to turn on rf
		CALL	PLLinit    
		CALL	PLLCalNreg
		CALL	PLLsetup
		MOVLW	D'10'
		CALL	Delay1mS
Startup1
		MOVLB	HIGH Mode
		MOVLW	modeRUN
		MOVWF	Mode
	; Read a few more setup parameters...
		MOVE	SyncWidth,Sync
		MOVLB	HIGH MaxChannels
		MOVF	MaxChannels,W
		MOVLB	HIGH NumChan
		MOVWF	NumChan
	; Init the button id byte
		CALL	ButtonIDinit
		CALL	BackupAircraft
;
; main program code goes here. There are two main loop
; modes, RUN and CAL. The mode is controlled by the RUN/CAL
; switch on the transmitter. The following functions are
; performed in each mode.
;
; RUN:
;	1.) Read all pots and perform the normalizations
;	2.) Calculate all servo position times
;	3.) Update display
;
; CALIBRATE:
;	1.) Look for received messages from host computer
;	2.) Process commands send from host
;	3.) Allow user to configure radio
;
; Every time around the main loop the run/cal switch is tested,
; if it remains the same for two passes then the mode is channged.
;
	; Turn on the timer        
ifdef	CountOn
		MOVLB	HIGH Cmode
		MOVLW	1
		MOVWF	Cmode
		MOVE	DWNSecs,Dsecs
		CLRF	Usecs
		CLRF	Umins
endif
main     
	; Test the stack overflow bit and light LED2 if its set!
		BTFSS	STKPTR,STKFUL
		GOTO	NoStackOverflow
		MOVLB	HIGH DDRB
		BCF	DDRB,LED2
		BCF	PORTB,LED2
NoStackOverflow
	; Test the run/cal switch...
		MOVLB	HIGH PORTEimage
		BTFSC	PORTEimage,RUNCAL
		GOTO	RUNmode
		; Here if in the CAL mode, test current system mode
		MOVLW	modeRUN
		CPFSEQ	Mode
		GOTO	CALmode
		; If here, beep three times and change to CAL mode
		MOVLB	HIGH BeepCyl
		MOVLW	5
		MOVFF	WREG,BeepCyl
		MOVLW	D'7'
		CALL	Beep		; Startup short beep!
		MOVLW	modeCAL
		MOVWF	Mode
		; Make sure the default aircraft is loaded...
		MOVLB	HIGH DefaultAircraft
		MOVF	DefaultAircraft,W
		MOVLB	HIGH Aircraft
		CPFSEQ	Aircraft
		GOTO	Reload
		GOTO	CALmode
Reload
		MOVWF	Aircraft
		CALL	LoadAircraft
		CALL	BackupAircraft
		GOTO	CALmode
;**********************************************************************************
; R U N    M O D E
;**********************************************************************************
RUNmode
		MOVLW	modeRUN
		MOVWF	Mode
		CALL	AlternateAircraft
		CALL	CalculateNormalizedPositions 
		CALL	TimerEnable
		; If master mode and AutoTrim button is pressed then
		; Apply positions from slave
		MOVLB	HIGH Master
		BTFSS	Master,0
		GOTO	RUNmodeNotMaster
		; Is auto trim button pressed?
		MOVLB	HIGH SWATRIM
		MOVF	SWATRIM,W
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	RUNmodeNotMaster
		; Test if this is the Futaba mode....
		MOVLB	HIGH MasterMode
		TSTFSZ	MasterMode
		GOTO	FutabaMode
		MOVE	MApos,Apos
		MOVE	MEpos,Epos
		MOVE	MRpos,Rpos
		MOVE	MTpos,Tpos
		GOTO	RUNmodeNotMaster
FutabaMode
	; Here if its Futaba mode and the student button (auto trim) is pressed
	; Set INT1 to high priority and TMR3 to low
		BSF	INTCON3,INT1IP,A
		BSF	INTCON3,INT1IE,A
		BCF	IPR2,CCP2IP,A
	; Set the FutabaStudent flag
		SETF	WREG
		MOVFF	WREG,FutabaStudent
		GOTO	FutabaDone
RUNmodeNotMaster
	; Here if not in Futabe student mode
	; Set INT1 to low priority and TMR3 to high
		BCF	INTCON3,INT1IP,A
		BSF	INTCON3,INT1IE,A
		BSF	IPR2,CCP2IP,A
	; Clear the FutabaStudent flag
		CLRF	WREG
		MOVFF	WREG,FutabaStudent
FutabaDone
		; If we are in student mode, do no more processing!
		MOVLB	HIGH Student
		BTFSC	Student,0
		GOTO	RUNmode3
		CALL	ThrottleTrim
		BTFSC	ALUSTA,Z
		GOTO	RUNmode3
		CALL	ApplyDualRates
		CALL	ApplyExpo
		CALL    ApplySnap
		CALL	AutoTrim
		CALL	ApplyTrims
		CALL	ApplyFixedMixersPrior
		CALL	ApplyMixers
		CALL	ApplyFixedMixers
		CALL	ApplySubTrims
		MOVLB	HIGH FMSflag
		TSTFSZ	FMSflag
		CALL	FMS
RUNmode3
		; Sync up with the PPM signal transmission.
		; This will insure we have time to update the channel times
		; before the ISR needs them
		CALL	SyncUp
		CALL	CalculateServoPositions

		CALL	ProcessCommand
		; We will update the display every 1/4 sec using timeout4
		MOVLB	HIGH TimeOut4
		TSTFSZ	TimeOut4
		GOTO	RUNmode2
		MOVLW	d'10'
		MOVWF	TimeOut4
		CALL	Display
RUNmode2
		GOTO	main
;**********************************************************************************
; C A L   M O D E
;**********************************************************************************
CALmode
	; Display the CAL mode message...
		MOVLW	LINE1
		CALL	LCDsendCMD
		PrintMess CALMES0
		MOVLW	LINE2
		CALL	LCDsendCMD
		PrintMess MES8
	; If option is pressed then enter the CAL function
		CALL	Option
		BTFSS	ALUSTA,C
		GOTO	CalNotSel
		CALL	Calibration
CalNotSel
	;
		CALL	CalculateNormalizedPositions
		CALL	ApplyDualRates
		CALL	ApplyExpo
		CALL    ApplySnap
		CALL	AutoTrim
		CALL	ApplyTrims
		CALL	ApplyFixedMixersPrior
		CALL	ApplyMixers
		CALL	ApplyFixedMixers
		CALL	ApplySubTrims
		CALL	CalculateServoPositions

		CALL	ProcessCommand
		GOTO	main
;******************************************************************


DisplayAircraftName
		MOVLB	0
	; Display the aircraft name on the second line
		MOVLW	D'16
		MOVWF	Breg
		MOVLW	LINE2
		CALL	LCDsendCMD
		MOVLW	LOW Name
		MOVWF	FSR1L
		MOVLW	HIGH Name
		MOVWF	FSR1H		
Next_Char
		MOVF	POSTINC1,W
		CALL	LCDsendData
		DECFSZ	Breg
		GOTO	Next_Char
		RETURN
;
; This is the run mode display update subroutine.
;
Display
		MOVLB	0
	; Display the Mixer states...
ifdef	ECMA1010display
		; Turn on the RF output ICON if RF is on
		MOVLB	HIGH SelFreq
		BTFSC	SelFreq,7
		GOTO	RFisOFF
		MOVLW	0F7
		CALL	LCDsendCMD
		PrintMess MRFON
RFisOFF
		MOVLW	0DC
		CALL	LCDsendCMD
		MOVLR	HIGH Backup
		MOVFP	AltAircraft,WREG
		CALL	SwitchTest
		MOVLW	99
		BTFSS	ALUSTA,C
		MOVLW	00
		CALL	LCDsendData
		MOVLW	LINE1+4
		CALL	LCDsendCMD
else
		MOVLW	LINE1+4
		CALL	LCDsendCMD
		MOVLW	' '
		CALL	LCDsendData
		MOVLR	HIGH SelFreq
		MOVLW	'R'
		BTFSC	SelFreq,7
		MOVLW	' '
		MOVLR	0
		CALL	LCDsendData
		MOVLR	HIGH Backup
		MOVFP	AltAircraft,WREG
		CALL	SwitchTest
		MOVLW	'A'
		BTFSS	ALUSTA,C
		MOVLW	' '
		CALL	LCDsendData
endif
		MOVLR	HIGH SWMIX1
		MOVFP	SWMIX1,WREG
		CALL	SwitchTest
		MOVLW	'M'
		BTFSC	ALUSTA,C
		MOVLW	'-'
		CALL	LCDsendData
		MOVLR	HIGH SWMIX2
		MOVFP	SWMIX2,WREG
		CALL	SwitchTest
		MOVLW	'M'
		BTFSC	ALUSTA,C
		MOVLW	'-'
		CALL	LCDsendData
		MOVLR	HIGH SWMIX3
		MOVFP	SWMIX3,WREG
		CALL	SwitchTest
		MOVLW	'M'
		BTFSC	ALUSTA,C
		MOVLW	'-'
		CALL	LCDsendData
ifndef	ECMA1010display
		MOVLW	' '
		CALL	LCDsendData
endif
	; Display the Battery voltage
		; Set the print position
		MOVLW	LINE1
		CALL	LCDsendCMD
		; Multiply the BattAlarm by 100 and place in CXreg
		MOVE	BattAlarm,AXreg 
		CLRF	AXreg+1
		MOVEC	D'100',BXreg
		CALL	Mult1616
		MOVE	CEXreg,CXreg		
		; Calculate the voltage
		MOVE	Vbat,AXreg
		MOVE	VmonG,BXreg
		CALL	Mult1616
		MOVFP	CEXreg+1,WREG
		MOVPF	WREG,CEXreg
		MOVFP	CEXreg+2,WREG
		MOVPF	WREG,CEXreg+1
		CLRF	CEXreg+2
		; Test the battery voltage, if its below the limit
		; then beep a bunch of times
		MOVLR	HIGH LValarm
		BTFSC	LValarm,0
		GOTO	NoAlarm
		MOVLR	HIGH CEXreg
		MOVFP	CXreg,WREG
		SUBWF	CEXreg,W
		MOVFP	CXreg+1,WREG
		SUBWFB	CEXreg+1,W
		; If result is negative then beep! 
		BTFSS	WREG,7
		GOTO	NoAlarm
		; Make noise!
		MOVLW	D'201'
		MOVLR	HIGH BeepCyl
		MOVWF	BeepCyl
		MOVLW	D'5'
		CALL	Beep 
		; Set the alarm flag so wo do not do this again!
		MOVLR	HIGH LValarm
		SETF	LValarm
	; Display the voltage
NoAlarm		
		MOVLR	HIGH CEXreg
		CALL	Int2Str
		MOVLW	' '
		MOVPF	WREG,Areg
		MOVLW	'0'
		CPFSGT	Buffer
		MOVPF	Areg,Buffer
		MOVFP	Buffer,WREG
		CALL	LCDsendData
		MOVFP	Buffer+1,WREG
		CALL	LCDsendData
		MOVLW	'.'
		CALL	LCDsendData
		MOVFP	Buffer+2,WREG
		CALL	LCDsendData  
	; If the Auto Trim button is pressed then display the total on time of
	; the transmitter
		MOVLR	HIGH SWATRIM
		MOVFP	SWATRIM,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	DispNoBT
		; Here is the Auto Trim button is pressed
		MOVLW	LINE1
		CALL	LCDsendCMD
		MOVE	BatteryTimer,CEXreg
		CALL	LCDintZS		
DispNoBT	
		; Test the BTflag and update the time if necessary
		MOVLR	HIGH BTflag
		BTFSS	BTflag,7
		GOTO	DispNoSaveBT   
		CLRF	BTflag
		; Here to update the time in EEPROM
		MOVLW	LOW BatteryTimer
		MOVFF	WREG,AXreg	; RAM address of data to write
		CLRF	WREG,A
		MOVFF	WREG,AXreg+1
		MOVFF	BatteryTimer,WREG
		CALL	EEPROMwriteByte

		MOVLW	LOW BatteryTimer+1
		MOVFF	WREG,AXreg	; RAM address of data to write
		CLRF	WREG,A
		MOVFF	WREG,AXreg+1
		MOVFF	BatteryTimer+1,WREG
		CALL	EEPROMwriteByte
DispNoSaveBT
	; Display the Throttle Adjust message if the TTflag is set
		CALL	ThrottleAdjustMessage
		BTFSC	ALUSTA,C
		GOTO	DispAircraftDone		
	; Display the receiver bat voltage if its non zero..
		CALL	RecVoltage
		BTFSC	ALUSTA,C
		GOTO	DispAircraftDone
	; Display The Tach RPM if enabled
		CALL	TackDisplay
		BTFSC	ALUSTA,C
		GOTO	DispAircraftDone
	; Call the Button ID function
		CALL	ButtonID
		; If timeout5 is not zero then exit...
		MOVLR	HIGH TimeOut5
		MOVFP	TimeOut5,WREG
		IORWF	WREG
		BTFSS	ALUSTA,Z
		GOTO	DispAircraftDone
	; Display the aircraft name on the second line
		; If student mode then display student
		MOVLR	HIGH Student
		BTFSS	Student,0
		GOTO	DispNotStudent
		MOVLW	LINE2
		CALL	LCDsendCMD
		PrintMess MES10
		GOTO	DispAircraftDone
DispNotStudent
		CALL	DisplayAircraftName
DispAircraftDone
	; Process the option button press and release
		MOVLR	HIGH PORTEimage
		BTFSC	PORTEimage,OPTION
		GOTO	Dsp1
		; Test if its been processed
		BTFSS	PORTElatch,OPTION
		GOTO	Dsp1
		; Beep one time to indicate we detected the
		; button...
		BCF	PORTElatch,OPTION
		MOVLW	D'1'
		MOVWF	BeepCyl
		MOVLW	D'5'
		CALL	Beep
	; If the mode is 1 set it to 0, if its 0 set it to 1
		MOVLR	HIGH Cmode
		TSTFSZ	Cmode
		GOTO	Dsp2
		; Here if counter mode is 0, set to 1 and start the down counter
		INCF	Cmode,F
		MOVE	DWNSecs,Dsecs
		CLRF	Usecs
		CLRF	Umins

		GOTO	Dsp1
Dsp2		
		; Here if counter mode is 1
		DECF	Cmode,F

Dsp1
	; Test the timer mode...
	; Display the down counter, do the following
	; at 1 min, beep 3 times
	; at 30 sec, beep 2 times
	; at 10 sec, beep 1 time
	; and one time at 5,4,3,2,1 sec
		MOVLR	HIGH Cmode
		BTFSS	Cmode,0
		GOTO	Dsp3 
		; Here if we are in the count down mode
		TSTFSZ	Dmins
		GOTO	Dsp3
		; Here if this is the last minute of the 
		; timer, test for and generate the warning beeps
		MOVLW	D'59'	
		CPFSEQ	DsecsLatch
		GOTO	Dsp3a
		MOVLW	5
		MOVWF	BeepCyl
		MOVLW	D'10'
		CALL	Beep
		GOTO	Dsp3
Dsp3a
		MOVLW	D'30'	
		CPFSEQ	DsecsLatch
		GOTO	Dsp3b
		MOVLW	3
		MOVWF	BeepCyl
		MOVLW	D'10'
		CALL	Beep
		GOTO	Dsp3
Dsp3b
		MOVLW	D'10'	
		CPFSEQ	DsecsLatch
		GOTO	Dsp3c
		MOVLW	1
		MOVWF	BeepCyl
		MOVLW	D'10'
		CALL	Beep
		GOTO	Dsp3
Dsp3c
		MOVLW	6	
		CPFSLT	DsecsLatch
		GOTO	Dsp3
		MOVLW	1
		MOVWF	BeepCyl
		MOVLW	D'10'
		CALL	Beep
		GOTO	Dsp3

Dsp3
		MOVLW	07F
		MOVWF	DsecsLatch
	; Display the current ON time or count down time... 
		; If Cmode = 0 then display the on time
		; If Cmode = 1 and CNTmode = 1 then display the down timer
		; If Cmode = 1 and CNTmode = 0 then display the up timer
		; If Cmode = 1 and CNTmode = 2 then display the down timer and stop at 0
		MOVFP	Secs,WREG       ; Move counter to DXreg
		MOVWF	DXreg
		MOVFP	Mins,WREG
		MOVWF	DXreg+1
		MOVLW	1
		CPFSEQ	Cmode
		GOTO	Dsp3d           ; Jump if Cmode is zero
	   ; Here if Cmode == 1
		MOVFP	Dsecs,WREG      ; Test down counter to see if its 0
		IORWF	Dmins,W
		BTFSC	ALUSTA,Z
		GOTO	DSP3d1          ; Jump if zero
	   ; Here if down counter has not reached 0	  
		MOVFP	Dsecs,WREG      ; Move down counter to DXreg
		MOVWF	DXreg
		MOVFP	Dmins,WREG
		MOVWF	DXreg+1
		MOVLW	0 
		MOVLR	HIGH CNTmode
		CPFSEQ	CNTmode
		GOTO	Dsp3d           ; If CNTmode != 0 then jump
DSP3d1	   ; Here if CNTmode == 0   
		MOVLW	2 
		MOVLR	HIGH CNTmode
		SUBWF   CNTmode,W
		BTFSC	ALUSTA,Z
		GOTO	Dsp3d1a         ; If CNTmode == 2 then jump
           ; Here if CNTmode != 2       
		MOVLR	HIGH Usecs      ; Move up time to DXreg
		MOVFP	Usecs,WREG
		MOVWF	DXreg
		MOVFP	Umins,WREG
		MOVWF	DXreg+1
		GOTO    Dsp3d
Dsp3d1a    ; Here if CNTmode == 2
                CLRF    WREG
                MOVLR   HIGH DXreg
		MOVWF	DXreg
		MOVWF	DXreg+1
Dsp3d	   ; Display the time in DXreg	                  
		MOVLR	HIGH DXreg
		MOVLW	LINE1+ONTIMEPOS
		CALL 	LCDsendCMD
		MOVFP	DXreg+1,WREG
		MOVPF	WREG,CEXreg
		CLRF	CEXreg+1
		CLRF	CEXreg+2
		CLRF	CEXreg+3
		CALL	LCDint2
		MOVLW	':'
		CALL	LCDsendData
		MOVFP	DXreg,WREG
		MOVPF	WREG,CEXreg
		CALL	LCDint2
		RETURN
                
; This function looks at the Timer enabling options:
;  1.) The enable switch
;  2.) The throttle stick position enable
; If both of these are true, then the TimerCount flag is
; set, FF. This function is called in the run main loop.                
TimerEnable    
	; Read the enabled switch status 
		MOVLR	HIGH TEnaSW
		MOVFP	TEnaSW,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	TE1       
	; Test the throttle position
		MOVLR	HIGH Tthres
		MOVLW	0
		CPFSGT	Tthres
		GOTO	TE2   
		MOVLR	HIGH Tpos
		BTFSC	Tpos+1,7
		GOTO	TE1
		MOVLR	HIGH Tthres
		MOVFP	Tthres,WREG
		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	Tpos,WREG
		SUBWF	CEXreg
		MOVFP	Tpos+1,WREG
		SUBWF	CEXreg+1,W
		BTFSC	ALUSTA,C
		GOTO	TE1  
	; Enable the counter 
TE2    		
		MOVLR	HIGH TimerCount
		SETF	TimerCount
		RETURN
TE1                               
		MOVLR	HIGH TimerCount
		CLRF	TimerCount
		RETURN

; This function tests the TTflag, if its set then the Throttle
; adjust message is printed on the second line of the display
; and the carry flag is set on exit.
ThrottleAdjustMessage
	; Test the TTflag
	        BCF	ALUSTA,C
		MOVLR	HIGH TTflag
		BTFSS	TTflag,7
		RETURN
	; Here to display message
		MOVLW	LINE2
		CALL	LCDsendCMD
		PrintMess MES24
	; Set carry flag and exit
	        BSF	ALUSTA,C	
		RETURN
		             
; This function will read ADC channel 13, this is the receiver
; voltage monitor channel. If the value is greater than a few 
; counts then the data is displayed on the second line of the 
; display. If the receiver value is displayed then this function
; returns with the carry flag set.
RecVoltage       
	; Read ADC positive reference channel 
		MOVLW	ADCrec
		CALL	ADCread		; Results are in Pos
		MOVLW	ADCrec
		CALL	ADCread		; Results are in Pos
	; Convert the ACD counts into the voltage
		MOVE	Pos,AXreg
		MOVE	VRmonG,BXreg
		CALL	Mult1616
	; Divide the value in CEXreg by 256
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg+1,WREG
		MOVWF	CEXreg
		MOVFP	CEXreg+2,WREG
		MOVWF	CEXreg+1
		MOVFP	CEXreg+3,WREG
		MOVWF	CEXreg+2
		CLRF	CEXreg+3
	; Now convert to a string...
		CALL	Int2Str                                  
		; The string is in Buffer, in millivolts
	; If the voltage is greater that 1 volt, then display it!
		MOVLR	HIGH Buffer
		MOVFP	Buffer,WREG
		IORWF	Buffer+1,W
		ANDLW	0F
		BCF	ALUSTA,C
		BTFSC	ALUSTA,Z
		RETURN
	; Here to display the value!
		MOVLW	LINE2
		CALL	LCDsendCMD
		PrintMess MES23
		MOVLW	LINE2 + RECVPOS
		CALL	LCDsendCMD
	        MOVLR	HIGH Buffer
	        MOVFP	Buffer,WREG
	        CALL	LCDsendData
	        MOVFP	Buffer+1,WREG
	        CALL	LCDsendData    
	        MOVLW	'.'
	        CALL	LCDsendData
	        MOVFP	Buffer+2,WREG
	        CALL	LCDsendData    
	        MOVFP	Buffer+3,WREG
	        CALL	LCDsendData
	; Set carry flag and exit
	        BSF	ALUSTA,C
		RETURN

;
; This is a IO test routine entered when the Option and Preset buttons are
; held down during power up. The display will show binary data for ports
; C and D on the top line, and G and H on the second line.
;
TestIO
		Release	PORTE,OPTION
		Release	PORTD,PRESET
TestIOa
ifdef ECMA1010display
		MOVLW	LINE1
		CALL    LCDsendCMD
		PrintMess MES0
		MOVLW	LINE2
		CALL    LCDsendCMD
		PrintMess MES0
		MOVLW	LINE3
		CALL    LCDsendCMD
		PrintMess MES0
		MOVLW	LINE4
		CALL    LCDsendCMD
		PrintMess MES0
endif
	; Read and display parallel IO ports
		MOVLW	LINE1
		CALL    LCDsendCMD	; First line of display
		MOVLB	HIGH PORTD	; Port D
		MOVFP	PORTD,WREG
		CALL	LCDbinary
ifdef ECMA1010display
		MOVLW	LINE2
		CALL    LCDsendCMD
endif
		MOVLB	HIGH PORTE	; Port E
		MOVFP	PORTE,WREG
		CALL	LCDbinary
		MOVLW	LINE3		; Second line of display
		CALL    LCDsendCMD
		MOVLB	HIGH PORTG	; Port G
		MOVFP	PORTG,WREG
		CALL	LCDbinary
ifdef ECMA1010display
		MOVLW	LINE4
		CALL    LCDsendCMD
endif
		MOVLB	HIGH PORTH	; Port H
		MOVFP	PORTH,WREG
		CALL	LCDbinary
	; Test LEDs
	; PortD bit 0 (Ail DR) = LED1
	; PortD bit 1 (Eve DR) = LED2
		MOVLB	HIGH PORTD
		MOVFP	PORTD,WREG
	        BSF     PORTC,LED1
	        BSF     PORTB,LED2
	        BTFSC   WREG,0
	        BCF     PORTC,LED1
	        BTFSC   WREG,1
	        BCF     PORTB,LED2
	; Test the buzzer = PORTD bit 2 (Rud DR)
	        BCF     PORTA,BUZZER
	        BTFSC   WREG,2
	        BSF     PORTA,BUZZER
	; Loop untill the option button is pressed...
		MOVLW	D'50'
		CALL	Delay1mS
		Pressed	PORTE,OPTION
		BTFSC	ALUSTA,C
		GOTO	TestIOa
		Release	PORTE,OPTION
	; Read the ADC channels...
ifdef ECMA1010display
		MOVLW	LINE3
		CALL    LCDsendCMD
		PrintMess MES0
		MOVLW	LINE4
		CALL    LCDsendCMD
		PrintMess MES0
endif
		MOVLW	LINE2
		CALL    LCDsendCMD
		PrintMess MES0
		MOVLR	HIGH AXreg
		CLRF	AXreg
TestIO1
		MOVLW	LINE1
		CALL    LCDsendCMD
		PrintMess MES3
		MOVLW	LINE1+TESTCHPOS
		CALL    LCDsendCMD
		MOVLR	HIGH AXreg
		MOVFP	AXreg,WREG
		CALL	LCDhex
		CALL	ADCread
		MOVLW	LINE1+TESTVALPOS
		CALL    LCDsendCMD
		MOVLB	HIGH ADRESH
		MOVPF	ADRESH,WREG
		CALL	LCDhex	
		MOVLB	HIGH ADRESL
		MOVPF	ADRESL,WREG
		CALL	LCDhex	
	; Delay
		MOVLW	D'50'
		CALL	Delay1mS
	; If option button is pressed then advance to next channel
	; after channel 12, exit
		Pressed	PORTE,OPTION
		BTFSC	ALUSTA,C
		GOTO	TestIO1
		Release	PORTE,OPTION
	; Advance ADC channel
		MOVLR	HIGH AXreg
		INCF	AXreg
		MOVLW	D'12'
		CPFSGT	AXreg
		GOTO	TestIO1
		GOTO	TestIOa

; This function will read the ADC channel defined in WREG 256 times and
; sum the results in CEXreg.
ReadADC256
	; First clear CEXreg
		MOVLR	HIGH CEXreg
		CLRF	CEXreg
		CLRF	CEXreg+1
		CLRF	CEXreg+2
		CLRF	CEXreg+3
	; Save Channel to Areg
		MOVWF	Areg,A
	; Setup Breg as a loop counter
		CLRF	Breg,A
	; Read the ADC
RD256a
		MOVF	Areg,W,A
		CALL	ADCread
	; Sum the result
		MOVLR	HIGH CEXreg
		MOVFP	ADRESL,W,A
		ADDWF	CEXreg
		MOVFP	ADRESH,W,A
		ADDWFC	CEXreg+1
		BTFSC	ALUSTA,C,A
		INCF	CEXreg+2
	; Do the loop counter test
		DECFSZ	Breg
		GOTO	RD256a
		RETURN
;
; This function reads data from the ADC channel defined in WREG.
; The results are in the ADC registers when this function returns.
; The results are also written to Pos.
; Areg will contain the channel number when this function returns
; as will WREG.
; The function ADClookup is called to translate the ADC channel number 
; into the value that will be used and the MSB of this lookup will
; define the reference to use, 0=ext, 1 = 5 volt internal supply.
;
ADCread
		MOVWF	Areg,A		; Save channel number
	; Setup ADC
		MOVLW	0A1		; Right justify and 1MHz conversion clock
		MOVWF	ADCON2,A
		MOVLW	0   		; Use VDD and VSS as reference
		MOVWF	ADCON1,A
	; Load the ADC channel number and reference data from the ADC table
		MOVFF	Areg,WREG
		CALL	ADClookup
	; If MSB is clear then use ext ref	
		BTFSS	WREG,7,A
		BSF	ADCON1,VCFG0,A	; Use external reference for positive supply
		BCF	WREG,7,A
ADCread1
	; Select the channel and start the conversion
		RLNCF	WREG,W,A
		RLNCF	WREG,W,A
		MOVWF	ADCON0,A
		BSF	ADCON0,ADON,A
		NOP			; delay to let the Mux settle
		BSF	ADCON0,GO,A
	; Wait for the ADC to finish
ADCread0
		BTFSC	ADCON0,DONE,A
		GOTO	ADCread0
	; Save results in Pos
		MOVLR	HIGH Pos
		MOVFF	ADRESL,Pos
		MOVFF	ADRESH,Pos+1
	; Restore WREG
		MOVFF	Areg,WREG
		RETURN

; This function will read the ADC channel again and sum this result
; with the value in Pos. This is used for oversampling.
ADCreadAgainandSum
		MOVLB	HIGH ADCON0
		BSF	ADCON0,GO
	; Wait for the ADC to finish
ADCreadAgain0
		BTFSC	ADCON0,DONE
		GOTO	ADCreadAgain0
	; Now sum with POS
		MOVLB	HIGH Pos
		MOVF	ADRESL,W,A
		ADDWF	Pos,F
		MOVF	ADRESH,W,A
		ADDWFC	Pos+1,F
		RETURN

; WREG has channel number.
OverSample
	; Read the ADC channel 4 times
		CALL	ADCread
		CALL	ADCreadAgainandSum
		CALL	ADCreadAgainandSum
		CALL	ADCreadAgainandSum
	; Now divide by 4, or 2 if we are oversampling
		MOVLR	HIGH Pos
		; Divide by 2
		RRCF	Pos+1
		BCF	Pos+1,7
		RRCF	Pos
ifndef		ENABLEOVERSAMPLE
		; Divide by 2
		RRCF	Pos+1
		BCF	Pos+1,7
		RRCF	Pos
endif
		RETURN


; Timer3 init routine.
Timer3Init
	; Write initial values into data arrays
		MOVLR	HIGH Pstate
		CLRF	Pstate
		CLRF	Secs
		CLRF	Mins
		MOVLW	TICKSPER
		MOVPF	WREG,Tick
	; Fill the channel times array with nominal values
		MOVEC	D'400',Sync
		MOVEC	D'400',NextTime
		CLRF	Psum
		CLRF	Psum+1
		MOVLW	D'16'
		MOVLR	HIGH Pstate
		MOVPF	WREG,NumChan
		CLRF	CHtimes
		CLRF	CHtimes+2
		CLRF	CHtimes+4
		CLRF	CHtimes+6
		CLRF	CHtimes+8
		CLRF	CHtimes+D'10'
		CLRF	CHtimes+D'12'
		CLRF	CHtimes+D'14'
		CLRF	CHtimes+D'16'
		CLRF	CHtimes+D'18'
		MOVLW	8
		MOVPF	WREG,CHtimes+1
		MOVPF	WREG,CHtimes+3
		MOVPF	WREG,CHtimes+5
		MOVPF	WREG,CHtimes+7
		MOVPF	WREG,CHtimes+9
		MOVPF	WREG,CHtimes+D'11'
		MOVPF	WREG,CHtimes+D'13'
		MOVPF	WREG,CHtimes+D'15'
		MOVPF	WREG,CHtimes+D'17'
		MOVPF	WREG,CHtimes+D'19'
	; Output initial Mod pin state and define as ouput
		BCF	DDRF,MOD,A	; Define as output
		BSF	PORTF,MOD,A	; Set initial state
	; Setup timer3 and turn on interrupts
	 	; Setup the compare register, using compare reg 2
		MOVLR	HIGH Sync
		MOVFP	Sync,WREG
		MOVLB	HIGH CCPR2L
		MOVPF	WREG,CCPR2L
		MOVLR	HIGH Sync + 1
		MOVFP	(Sync + 1),WREG
		MOVLB	HIGH CCPR2H
		MOVPF	WREG,CCPR2H
		MOVLW	0A			; Interrupt on conpare equal counter
						; (0B = reset timer 3)
		MOVLB	HIGH CCP2CON
		MOVPF	WREG,CCP2CON		; Setup the condition reg
		; Enable the interrupt, compare reg 2. timer 3 does not
		; generate an interrupt
		MOVLB	HIGH PIE2
		BSF	PIE2,CCP2IE
		MOVLB	HIGH PIR2
		BCF	PIR1,CCP2IF
		; Configure timer 3, sync count
		MOVLB	HIGH T3CON
 		MOVLW	08
 		MOVPF	WREG,T3CON
 		BSF	T3CON,TMR3ON
		RETURN

; Timer3 interrupt service routine
;
;   This function generates the PPM output signal. A state
;   variable Pstate controls the function. When a state ends
;   in an odd number then we are outputting the sync pulse.
;   Sync pulses have a constant width.
;
;   Timer 3 uses compare reg 2. When the compare reg matches the
;   counter then the counter is reset and an interrupt is generated.
;
TIMER3ISR
	; Output the MOD pin state if this is not futaba master mode and
	; enabled for the student
		MOVLB	HIGH FutabaStudent
		BTFSS	FutabaStudent,0
		BTG	PORTF,MOD,A
	; Output the AUXOUT signal
		MOVLB	HIGH AUXMODE
		BTFSS	AUXMODE,7
		GOTO	AuxServoChanMode
		BTG	PORTH,AUXOUT,A
		GOTO	EndAuxState
AuxServoChanMode
		MOVLB	HIGH AUXSTATE
		BTFSC	AUXSTATE,0
		GOTO	AuxStateClr
		BSF	PORTH,AUXOUT,A
		GOTO	EndAuxState
AuxStateClr
		BCF	PORTH,AUXOUT,A
EndAuxState
	; Set the timers next compare value, sum curret value with NextTime
		MOVLB	HIGH NextTime
		MOVFF	CCPR2L,WREG
		ADDWF	NextTime
		MOVFF	CCPR2H,WREG
		ADDWFC	NextTime+1

		MOVFF	NextTime,WREG
		MOVFF	WREG,CCPR2L

		MOVFF	(NextTime + 1),WREG
		MOVFF	WREG,CCPR2H
	; Advance to next state
		MOVLB	HIGH Pstate
		CLRF	WREG,A
		CPFSGT	Pstate
		CALL	RTC		; Do the real time clock stuff.
					; This happens at 40 Hz
		MOVLB	HIGH Pstate
		INCF	Pstate
		MOVFF	Pstate,WREG
		ANDLW	0FE
		CPFSLT	NumChan
		GOTO	TIMER3ISR0
	; IF here reset the state to 0
		CLRF	Pstate
		; Calculate the time to the next output sequence,
		; 40Hz rate
		MOVLW	LOW CYCLECOUNTS
		MOVFF	WREG,NextTime
		MOVFF	Psum,WREG
		SUBWF	NextTime,F
		MOVLW	HIGH CYCLECOUNTS
		MOVFF	WREG,NextTime+1
		MOVFF	Psum+1,WREG
		SUBWFB	NextTime+1,F
		CLRF	Psum
		CLRF	Psum+1
		GOTO	TIMER3ISR3
TIMER3ISR0
	; Test for an odd state number. If its odd then we
	; output the sync pulse time
		BTFSS	Pstate,0
		GOTO	TIMER3ISR1
		MOVFF	Sync,WREG
		MOVFF	WREG,NextTime
		MOVFF	Sync+1,WREG
		MOVFF	WREG,NextTime+1
	; Test if this channel position is being output to the
	; AUXOUT pin
		MOVFF	AUXMODE,WREG
		MOVLB	HIGH AUXSTATE
		BSF	AUXSTATE,0
		CPFSEQ	Pstate
		GOTO	TIMER3ISR2
		BCF	AUXSTATE,0
		GOTO	TIMER3ISR2
	; Test if this is the 9th chanel, if so then send
	; the sum divided by 16
TIMER3ISR1
;		MOVFP	Pstate,WREG
		MOVLW	D'18'
;		CPFSEQ	NumChan
		CPFSEQ	Pstate                  ; This should fix the channel 9 bug
		GOTO	TIMER3ISR1a
		MOVFF	Psum,WREG
		MOVFF	WREG,NextTime
		MOVFF	Psum+1,WREG
		MOVFF	WREG,NextTime+1
		RRCF	NextTime+1,F
		RRCF	NextTime,F
		RRCF	NextTime+1,F
		RRCF	NextTime,F
		RRCF	NextTime+1,F
		RRCF	NextTime,F
		RRCF	NextTime+1,F
		RRCF	NextTime,F
		MOVLW	0F
		ANDWF	NextTime+1,F
		GOTO	TIMER3ISR2
	; Get the next state time using indirect addressing
TIMER3ISR1a
		MOVLW	HIGH ChannelOrder
		MOVFF	WREG,FSR0H
		MOVLW	ChannelOrder
		MOVFF	WREG,FSR0L
		MOVFF	Pstate,WREG
		RRCF	WREG,W,A
		BCF	WREG,7,A
		DECF	WREG,W,A
		ADDWF	FSR0L,F,A
		CALL	SelectOutputChannel
		; Subtract the Sync pulse width from this time
		MOVFF	Sync,WREG
		SUBWF	NextTime
		MOVFF	Sync+1,WREG
		SUBWFB	NextTime+1
	; Now sum the channel times
TIMER3ISR2
		MOVFF	NextTime,WREG
		ADDWF	Psum,F
		MOVFF	NextTime+1,WREG
		ADDWFC	Psum+1,F
	; Clear the interrupt bit and exit
TIMER3ISR3
		MOVLB	HIGH PIR2
		BCF	PIR2,CCP2IF
		RETURN

; This function is called at 40Hz and is responsible for all
; time generation. Up to 10mS can be spent in this routine.
RTC
	; Test the USARTS
		CALL	USART1reset
		CALL	USART2reset
	; Bypass the overrun test if not in the run mode
		MOVLR	HIGH Mode
		MOVLW	modeRUN
		CPFSEQ	Mode
		GOTO	NotOverrunTest
	; Test the OVERRUN flag if set then turn on the LED
		MOVLB	HIGH OVERRUN
		BSF	PORTC,LED1,A
		BTFSC	OVERRUN,0
		BCF	PORTC,LED1,A
	; Always set the OVERRUN flag
		MOVLW	0FF
		MOVWF	OVERRUN
NotOverrunTest
	; Insure that the Mod pin is in the correct state
		BCF	PORTH,AUXOUT,A
		MOVLR	HIGH SHIFT
		BTFSC	SHIFT,7
		GOTO	RTCx
		BCF	PORTF,MOD,A
		GOTO	RTCy
RTCx
		BSF	PORTF,MOD,A
RTCy
		MOVLR	HIGH Tick
		DECFSZ	Tick
		GOTO	RTC1
	; If here its time to inc the secs, here one time per second
	; First test the down counter and dec if its not zero
		CALL	TachRead
		MOVLB	HIGH Cmode
		BTFSS	Cmode,0
		GOTO	RTC1a
		MOVLB	HIGH TimerCount
		MOVLW	0FF
		CPFSEQ	TimerCount
		GOTO	RTC1a		; Jump is not enabled
		MOVFF	Dsecs,WREG
		IORWF	Dmins,W
		BTFSC	ALUSTA,Z,A
		GOTO	RTC1d
	; Dec the down counter...
		TSTFSZ	Dsecs
		GOTO	RTC1b
		; Here if Sec is zero
		MOVLW	D'60'
		MOVWF	Dsecs
		DECF	Dmins,F
RTC1b
		DECF	Dsecs,F
RTC1c
		MOVF	Dsecs,W
		MOVWF	DsecsLatch 
	; If CNTmode != 0 (down) and the down count times are zero,
	; then reset the up counters to zero
		MOVLB	HIGH CNTmode
		CLRF	WREG,A
		IORWF   CNTmode,W
		BTFSC	ALUSTA,Z,A
		GOTO	RTC1d
		MOVLB	HIGH Dsecs
		MOVF	Dsecs,W
		IORWF	Dmins,W
		BTFSC	ALUSTA,Z,A
		GOTO	RTC1d
		CLRF	Usecs
		CLRF	Umins	
		GOTO	RTC1a		
	; Here to inc the up counter
RTC1d
                MOVLB   HIGH Usecs
		INCF	Usecs
		MOVLW	D'60'
		CPFSEQ	Usecs
		GOTO	RTC1a
		CLRF	Usecs
		INCF	Umins
RTC1a
		MOVLW	TICKSPER
		MOVFF	WREG,Tick
		INCF	Secs
		MOVLW	D'60'
		CPFSEQ	Secs
		GOTO	RTC1
	; If here its time to inc the minutes, here one time per minute
		CLRF	Secs
		INCF	Mins
		; Increment the battery timer and set the flag            
		MOVLB	HIGH BatteryTimer
		INCF	BatteryTimer
		BTFSC	ALUSTA,Z,A
		INCF	BatteryTimer+1
		MOVLB	HIGH BTflag
		SETF	BTflag				
RTC1              
	; Send an S to tell the Slave its ok to send!
		MOVLB	HIGH Master
		BTFSS	Master,0
		GOTO	RTC1NotMaster
		MOVLW	'S'
		CALL	USART2sendChar
		; Clear the MasterState variable
		MOVLB	HIGH MasterState
		CLRF	MasterState
RTC1NotMaster
	; Debounce port D
		MOVLB	HIGH PORTDimage
		MOVFF	PORTD,WREG
		XORWF	PORTDlast,F
		BTFSS	ALUSTA,Z,A
		MOVWF	PORTDimage
		MOVWF	PORTDlast
		MOVFF	PORTDimage,WREG
		IORWF	PORTDlatch,F
	; Debounce port E
		MOVLB	HIGH PORTEimage
		MOVFF	PORTE,WREG
		XORWF	PORTElast,F
		BTFSS	ALUSTA,Z,A
		MOVWF	PORTEimage
		MOVWF	PORTElast
		MOVFF	PORTEimage,WREG
		IORWF	PORTElatch,F
	; Test the TimeOut counters
		MOVLB	HIGH TimeOut
		TSTFSZ	TimeOut
		DECF	TimeOut
		TSTFSZ	TimeOut1
		DECF	TimeOut1
		TSTFSZ	TimeOut2
		DECF	TimeOut2
		TSTFSZ	TimeOut3
		DECF	TimeOut3
		TSTFSZ	TimeOut4
		DECF	TimeOut4
		TSTFSZ	TimeOut5
		DECF	TimeOut5
	; Do the buzzer stuff...
		TSTFSZ	BeepCtr
		GOTO	RTC2
		RETURN
RTC2	; Here if the buzzer is active
		DECFSZ	BeepCtr
		RETURN
		BTG	PORTA,BUZZER,A
		DCFSNZ	BeepCyl
		RETURN
		MOVFF	BeepTicks,WREG
		MOVFF	WREG,BeepCtr
		RETURN

; Call this function with the number of ticks to beep in WREG
; BeepCly is assumed set...
Beep
		MOVFF	WREG,BeepTicks
		MOVFF	WREG,BeepCtr
	; Turn it on!
		MOVFF	BuzPol,WREG
		TSTFSZ	WREG,A
		GOTO	BuzInvert
ifdef		ADAPTER
		BSF	PORTA,BUZZER,A 
else
		BCF	PORTA,BUZZER,A 
endif
		RETURN
BuzInvert:
ifdef		ADAPTER
		BCF	PORTA,BUZZER,A 
else
		BSF	PORTA,BUZZER,A 
endif
		RETURN


; This routine sends the value in Areg MSB first. The number of bits to send
; are defined in Breg. Both Areg and Breg are destroyed.
PLLsend
	; Select the bank
		MOVLB	HIGH Areg
	; Set the data line
		BTFSC	Areg,7
		GOTO	PLLsend1
		BCF	PORTB,SDObit
		GOTO	PLLsend2
PLLsend1
		BSF	PORTB,SDObit
PLLsend2
	; Pulse the clock line
		BSF	PORTC,CLK
		BCF	PORTC,CLK
	; Loop untill finished
		RLNCF	Areg
		DECFSZ	Breg
		GOTO	PLLsend
		RETURN

; This function powers the PLL down and shuts off the RF output stage.
PLLpowerDown               
		MOVLB	HIGH PLLinitWORD
		MOVF	PLLinitWORD+2,W
		MOVWF	Areg
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend  
		MOVLB	HIGH PLLinitWORD
		MOVF	PLLinitWORD+1,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend 
		MOVLB	HIGH PLLinitWORD
		MOVF	PLLinitWORD,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		; Pulse the load line
		BSF	PORTG,PLLCS,A
		BCF	PORTG,PLLCS,A
		RETURN

; This function is used to calculate the PLL register N.
PLLCalNreg
        ; Calculate N, N=FCF/PDF
                MOVE24  FCF,CEXreg
                MOVE    PDF,DEXreg
                CALL    Divide2416
        ; Add the selected channel to the result. To allow the phase lock freq
        ; to be different that the channel spacing, the variable PMUL is provided.
                MOVLB   HIGH SelFreq
                MOVF    SelFreq,W
                MOVLB	HIGH PMUL
                MULWF	PMUL
                MOVF	PRODL,W
                MOVLB   HIGH CEXreg
                ADDWF   CEXreg,F
                BTFSC   ALUSTA,C
                INCF    CEXreg+1
                BTFSC   ALUSTA,C
                INCF    CEXreg+2
         ; Now move the result to Nreg and add the control bits...
                MOVLB   HIGH Nreg
                CLRF    Nreg
                CLRF    Nreg+1
                CLRF    Nreg+2
                MOVLB   HIGH CEXreg
                MOVF    CEXreg,W
                RLNCF   WREG
                RLNCF   WREG
                BSF     WREG,0
                BCF     WREG,1
                ANDLW   01F
                BTFSC   CEXreg,3
                BSF     WREG,7
                MOVLB   HIGH Nreg
                MOVWF   Nreg
                ; Now the MS two bytes...
                MOVLB   HIGH CEXreg   
                RLCF    CEXreg+0
                RLCF    CEXreg+1
                RLCF    CEXreg+2
                RLCF    CEXreg+0
                RLCF    CEXreg+1
                RLCF    CEXreg+2
                RLCF    CEXreg+0
                RLCF    CEXreg+1
                RLCF    CEXreg+2
                RLCF    CEXreg+0
                RLCF    CEXreg+1
                RLCF    CEXreg+2
                MOVF    CEXreg+1,W
                MOVLB   HIGH Nreg
                MOVWF   Nreg+1
                MOVLB   HIGH CEXreg
                MOVF    CEXreg+2,W
                ANDLW   01F
                MOVLB   HIGH Nreg
                IORLW   HICUR
                MOVWF   Nreg+2
                RETURN

; This routine initializes the PLL. The three regs F, R, and N are downloaded to
; the PLL.
PLLsetup         
	; Calculate the Nreg
		CALL	PLLCalNreg
	; F register
		MOVLB	HIGH Freg
		MOVF	Freg+2,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		MOVLB	HIGH Freg
		MOVF	Freg+1,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		MOVLB	HIGH Freg
		MOVF	Freg,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		; Pulse the load line
		BSF	PORTG,PLLCS,A
		BCF	PORTG,PLLCS,A
	; R register
		MOVLB	HIGH Rreg
		MOVF	Rreg+2,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		MOVLB	HIGH Rreg
		MOVF	Rreg+1,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		MOVLB	HIGH Rreg
		MOVF	Rreg,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		; Pulse the load line
		BSF	PORTG,PLLCS,A
		BCF	PORTG,PLLCS,A
	; N register
		MOVLB	HIGH Nreg
		MOVF	Nreg+2,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		MOVLB	HIGH Nreg
		MOVF	Nreg+1,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		MOVLB	HIGH Nreg
		MOVF	Nreg,W
		MOVWF	Areg,A
		MOVLW	8
		MOVWF	Breg,A
		CALL	PLLsend
		; Pulse the load line
		BSF	PORTG,PLLCS,A
		BCF	PORTG,PLLCS,A
		RETURN
;
; This function sets up the port directions and initalizes the data variables
; for the PLL.     
; The PLL PIC reset bit is set to 0
;
; Fband:
;     1 = 50 MHz
;     2 = 53 MHz
;     3 = 72 MHz
;
PLLinit
	; Set port directions and initial states
		MOVLB	HIGH PORTB
		BCF	DDRB,SDObit
		BCF	DDRC,CLK
		BCF	DDRB,PLLRST
		BCF	PORTB,PLLRST
		BCF	PORTB,SDObit
		BCF	PORTC,CLK
		BCF	DDRG,PLLCS,A
		BCF	PORTG,PLLCS,A
	; Setup the PLL variables depending on the Fband value
	        MOVLB   HIGH Fband
	        BTFSS   Fband,0
	        GOTO    PLLinit0
	        BTFSC   Fband,1
	        GOTO    PLLinit0
	; Here if its the 50MHz band
		MOVE24	Freg50,Freg
	 	MOVE24	Rreg50,Rreg
	 	MOVEC24 D'50800',FCF
	 	MOVEC	D'20',PDF
	 	MOVLB	HIGH FCN   
	 	CLRF	FCN
	 	MOVLW	D'10'
	 	MOVWF	NUMFREQ
	 	MOVLW	1
	 	MOVWF	PMUL
	        RETURN
PLLinit0
	        MOVLB   HIGH Fband
	        BTFSC   Fband,0
	        GOTO    PLLinit1
	        BTFSS   Fband,1
	        GOTO    PLLinit1
	 ; Here if its the 53MHz band
	 	MOVE24	Freg53,Freg
	 	MOVE24	Rreg53,Rreg
	 	MOVEC24 D'53100',FCF
	 	MOVEC	D'100',PDF
	 	MOVLB	HIGH FCN   
	 	CLRF	FCN
	 	MOVLW	D'8'
	 	MOVWF	NUMFREQ 
	 	MOVLW	1
	 	MOVWF	PMUL
	        RETURN
PLLinit1       
	        MOVLB   HIGH Fband
	        BTFSC   Fband,0
	        GOTO    PLLinit2
	        BTFSC   Fband,1
	        GOTO    PLLinit2
	 ; Here if its the 72MHz band
		MOVE24	Freg72,Freg
	 	MOVE24	Rreg72,Rreg
	 	MOVEC24 D'72010',FCF
	 	MOVEC	D'10',PDF
	 	MOVLB	HIGH FCN
	 	MOVLW	D'11'   
	 	MOVWF	FCN
	 	MOVLW	D'50'
	 	MOVWF	NUMFREQ
	 	MOVLW	2
	 	MOVWF	PMUL
	        RETURN         
PLLinit2
		RETURN



;****** Hardware INTERRUPT 1 SERVICE HANDLER
;
; This interrupt is used to support the Futaba buddy box operation.
; The ppm signal from a futaba encoder is assumed to be connected to
; the INT1 pin of the CPU.
; This pin is also used for the Tach. The blade detector in the tach
; module is connected to this pin. If the tach is enabled then this
; routine will count prop revolutions.
;
INT1ISR
   ; Test for for the tach module
		BTFSC	PORTH,TACHENA,A
		GOTO	NoTach
   ; Here if tach module is present
   	; If timer 0 is enabled then save its value and advance blade counter
	        BTFSS	T0CON,TMR0ON
   		GOTO	TimerOff
		MOVFF 	TMR0L,BladeTime
		MOVFF	TMR0H,BladeTime+1	; Save blade time count
		MOVLB	HIGH  BladeDet
		INCF	BladeDet		; Advance blade detector count
		BTFSC	ALUSTA,Z
		INCF	BladeDet+1
		BCF	INTCON3,INT1IF
		RETURN
   	; If timer 0 is disabled and blade counter is 0 then enable counter
TimerOff   	
		MOVLB	HIGH  BladeDet
		MOVF 	BladeDet,W
		IORWF	BladeDet+1,W
		BCF	INTCON3,INT1IF
		BTFSS	ALUSTA,Z
		RETURN   			; If blade count is non zero, exit
   		; Enable counter
		CLRF	WREG
		MOVFF	WREG,TMR0H
		MOVFF	WREG,TMR0L
	        BSF	T0CON,TMR0ON
		BCF	INTCON3,INT1IF
		RETURN	
   ; Here if no tach module has been detected
NoTach
	; Toggle the edge trigger and read status
	        BTG	INTCON2,INTEDG1,A
	; If the Auto Trim button is not pressed then exit. This state is indicated
	; by INT1 being low prority
        	BTFSS	INTCON3,INT1IP,A	; If INT1 is set to low priority then exit
        	GOTO	INT1ISR_EXIT		
	; Test the SHIFT value 
		MOVLB	HIGH SHIFT
		BTFSS	SHIFT,0
		GOTO	ACESHIFT
	; Here for normal shift 
	        BTFSS	INTCON2,INTEDG1,A
	        BCF	PORTF,MOD,A
	        BTFSC	INTCON2,INTEDG1,A
	        BSF	PORTF,MOD,A
	        GOTO	INT1ISR_EXIT
ACESHIFT                       
	; Here for ACE shift
	        BTFSS	INTCON2,INTEDG1,A
	        BSF	PORTF,MOD,A
	        BTFSC	INTCON2,INTEDG1,A
	        BCF	PORTF,MOD,A
	; Exit
INT1ISR_EXIT    
		BCF	INTCON3,INT1IF,A
                RETURN



;
; Delay subroutine. Delay = 2uS * WREG value
;
Delay2uS
		NOP
		DECFSZ	WREG
		GOTO	Delay2uS
		RETURN

;
; Delay subroutine. Delay = 1mS * Areg value
;
Delay1mS
		MOVWF	Areg
Delay1mS0
		MOVLW	D'250'
		CALL	Delay2uS
		MOVLW	D'250'
		CALL	Delay2uS
		DECFSZ	Areg
		GOTO	Delay1mS0
		RETURN

;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;
; EEPROM read/write functions
;
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

; This function reads a byte from EEPROM.
;
;	AXreg = EEPROM address
;	WREG = data byte read from EEPROM
EEPROMreadByte
		MOVFF 	AXreg+1,WREG 	;
		MOVWF 	EEADRH,A	; Upper bits of Data Memory Address to read
		MOVFF 	AXreg,WREG 	;
		MOVWF 	EEADR,A		; Lower bits of Data Memory Address to read
		BCF 	EECON1, EEPGD,A	; Point to DATA memory
		BCF 	EECON1, CFGS,A 	; Access EEPROM
		BSF 	EECON1, RD,A 	; EEPROM Read
		MOVF 	EEDATA, W,A 	; W = EEDATA
		RETURN
		
; This function writes a byte to EEPROM.
;
;	AXreg = EEPROM address
;	WREG = data byte to write to EEPROM
EEPROMwriteByte
	; Write the byte
		MOVWF 	EEDATA,A	; Data Memory Value to write
		MOVFF 	AXreg+1,WREG 	;
		MOVWF 	EEADRH,A	; Upper bits of Data Memory Address to write
		MOVFF 	AXreg,WREG 	;
		MOVWF 	EEADR,A		; Lower bits of Data Memory Address to write
		BCF 	EECON1, EEPGD,A	; Point to DATA memory
		BCF 	EECON1, CFGS,A 	; Access EEPROM
		BSF 	EECON1, WREN,A 	; Enable writes
		BCF 	INTCON, GIE,A 	; Disable Interrupts
		MOVLW 	55h 		;
		MOVWF 	EECON2,A	; Write 55h
		MOVLW 	0AAh 		;
		MOVWF 	EECON2,A	; Write 0AAh
		BSF 	EECON1, WR,A 	; Set WR bit to begin write
		BSF 	INTCON, GIE,A 	; Enable Interrupts
	; Wait for EEIF bit to set
EEPROMwriteByteWait
		BTFSS 	PIR2,EEIF,A
		GOTO	EEPROMwriteByteWait
		BCF	PIR2,EEIF,A
		RETURN

;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;
; Flash configuration storage routines
;
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
; This function will format the Flash configuration memory.
; The default data is used for this format opertion.
FormatFlash
		MOVLW	LINE1
		CALL    LCDsendCMD
	; display the accept message
		; Display format message
		PrintMess MES17
	; Make sure the pilot is ok with this!
		MOVLW	LINE2
		CALL    LCDsendCMD
		PrintMess MES7
		CALL	YesNo
		BTFSS	ALUSTA,C
		GOTO	FSexit
	; Display the formating message
		MOVLW	LINE2
		CALL    LCDsendCMD
		PrintMess MES19
	; Here if its OK to format, Load the default parameters
		CALL	LoadDefaults
		CALL	SaveGeneral
	; Setup loop counter to format all aircraft setups
		MOVLB	HIGH Dtemp
		MOVLW	NumAircraft
		MOVWF	Dtemp
FS03
		MOVFF	Aircraft,WREG	; Load aircraft number
		CALL	SaveAircraft
		MOVLB	HIGH Aircraft
		INCF	Aircraft	; Next Aircraft
		; Now advance the generic aircraft name's, "MODEL XX"
		MOVLB	HIGH Name
		INCF	Name+7
		; Look to see if it's greater that '9', 3A
		MOVLW	3A
		CPFSEQ	Name+7
		GOTO	FS04
		; Now advance Name+6 and set Name+7 to '0'
		INCF	Name+6
		MOVLW	30
		MOVWF	Name+7
	; Loop till finished....
FS04
		MOVLB	HIGH Dtemp
		DECFSZ	Dtemp
		GOTO	FS03
	; Here when we are finished, Reload the setup information
FSexit
		CALL	LoadGeneral
		MOVFF	Aircraft,WREG
		CALL	LoadAircraft
		RETURN


; This function will read data from flash memory and save it
; at the address in reg AXreg.  The following registers are 
; assumed defined when this call is made:
;
;	AXreg  = Destination address in ram
;	CEXreg = Flash memory address 
;	Areg   = Number of bytes to read
;
FlashRead
	; Set table pointer with Flash program memory address
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg+2,W
		MOVWF	TBLPTRU,A
		MOVFP	CEXreg+1,W
		MOVWF	TBLPTRH,A
		MOVFP	CEXreg,W
		MOVWF	TBLPTRL,A
	; Setup indirection regs
		MOVLR	HIGH AXreg
		MOVFP	AXreg+1,W
		MOVWF	FSR1H,A
		MOVFP	AXreg,W
		MOVWF	FSR1L,A
FlashRead1
		TBLRD*+
		MOVF	TABLAT,W
		MOVWF	POSTINC1
		DECF	Areg
		TBLRD*+
		MOVF	TABLAT,W
		MOVWF	POSTINC1
		DECFSZ	Areg
		GOTO	FlashRead1
		RETURN


; This function will erase 64 byte blocks of Flash program memory. 
; The following registers are defined when this function
; is called:
;
;	CEXreg = Flash memory address, pointer to first block 
;	Areg   = Number of 64 byte blocks to erase
FlashErase
	; Load the pointer to flash block to erase
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg+2,W
		MOVWF	TBLPTRU,A
		MOVFP	CEXreg+1,W
		MOVWF	TBLPTRH,A
		MOVFP	CEXreg,W
		MOVWF	TBLPTRL,A
	; Erase this block
		BSF 	EECON1, EEPGD,A	; point to Flash program memory
		BCF 	EECON1, CFGS,A 	; access Flash program memory
		BSF 	EECON1, WREN,A 	; enable write to memory
		BSF 	EECON1, FREE,A 	; enable Row Erase operation
		BCF 	INTCON, GIE,A 	; disable interrupts
		MOVLW 	55h
		MOVWF 	EECON2,A	; write 55h
		MOVLW 	0AAh
		MOVWF 	EECON2,A	; write 0AAh
		BSF 	EECON1, WR,A 	; start erase (CPU stall)
		NOP
		BSF 	INTCON, GIE,A 	; re-enable interrupts
	; Advance to the next block by adding 64 to CEXreg
		MOVLR	HIGH CEXreg
		MOVLW	D'64'
		ADDWF	CEXreg
		MOVLW	0
		ADDWFC	CEXreg+1
		ADDWFC	CEXreg+2
	; Loop till all blocks are erased
		DECFSZ	Areg,F,A
		GOTO	FlashErase
		RETURN

; This function will write data to flash memory. The source
; data address is in reg AXreg.  The following registers are 
; assumed defined when this call is made:
;
;	AXreg  = Ram source memory address 
;	CEXreg = Destination address in Flash, must be on 64 byte page
;	Areg   = Number of 64 byte blocks to program
;
FlashWrite
		CALL	SyncUp
	; Load the pointer to flash block
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg+2,W
		MOVWF	TBLPTRU,A
		MOVFP	CEXreg+1,W
		MOVWF	TBLPTRH,A
		MOVFP	CEXreg,W
		MOVWF	TBLPTRL,A
	; Erase this block
		BSF 	EECON1, EEPGD,A	; point to Flash program memory
		BCF 	EECON1, CFGS,A 	; access Flash program memory
		BSF 	EECON1, WREN,A 	; enable write to memory
		BSF 	EECON1, FREE,A 	; enable Row Erase operation
		BCF 	INTCON, GIE,A 	; disable interrupts
		MOVLW 	55h
		MOVWF 	EECON2,A	; write 55h
		MOVLW 	0AAh
		MOVWF 	EECON2,A	; write 0AAh
		BSF 	EECON1, WR,A 	; start erase (CPU stall)
		BSF 	INTCON, GIE,A 	; re-enable interrupts
	; Write the buffer to holding reg
		TBLRD*- 		; dummy read decrement
		MOVLR	HIGH AXreg
		MOVFP	AXreg+1,W 	; point to buffer
		MOVWF 	FSR1H,A
		MOVFP	AXreg,W
		MOVWF 	FSR1L,A
		MOVLW 	D'64' 		; number of bytes in holding register
		MOVWF 	Breg,A
WRITE_BYTE_TO_HREGS
		MOVFF 	POSTINC1, WREG 	; get low byte of buffer data
		MOVWF 	TABLAT,A	; present data to table latch
		TBLWT+* 		; write data, perform a short write
					; to internal TBLWT holding register.
		DECFSZ 	Breg,F,A	 	; loop until buffers are full
		BRA 	WRITE_BYTE_TO_HREGS
	; Program the block
		BSF 	EECON1, EEPGD,A	; point to Flash program memory
		BCF 	EECON1, CFGS,A 	; access Flash program memory
		BSF 	EECON1, WREN,A 	; enable write to memory
		BCF 	INTCON, GIE,A 	; disable interrupts
		MOVLW 	55h
		MOVWF 	EECON2,A	; write 55h
		MOVLW 	0AAh
		MOVWF 	EECON2,A	; write 0AAh
		BSF 	EECON1, WR,A 	; start program (CPU stall)
		BSF 	INTCON, GIE,A 	; re-enable interrupts
		BCF 	EECON1, WREN,A 	; disable write to memory
	; Advance pointers to next block
		MOVLR	HIGH CEXreg
		MOVLW	D'64'
		ADDWF	CEXreg
		MOVLW	0
		ADDWFC	CEXreg+1
		ADDWFC	CEXreg+2
		MOVLR	HIGH AXreg
		MOVLW	D'64'
		ADDWF	AXreg
		MOVLW	0
		ADDWFC	AXreg+1
	; Loop till all blocks are processed
		DECFSZ	Areg,F,A
		GOTO	FlashWrite
		RETURN	

; This function will write data to flash memory. The source
; data address is in reg AXreg.  The following registers are 
; assumed defined when this call is made:
;
;	AXreg  = Ram source memory address 
;	CEXreg = Destination address in Flash, must be on 64 byte page
;	Areg   = Number of 64 byte blocks to program
;
FlashWrite_8720
	; Load the pointer to flash block
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg+2,W
		MOVWF	TBLPTRU,A
		MOVFP	CEXreg+1,W
		MOVWF	TBLPTRH,A
		MOVFP	CEXreg,W
		MOVWF	TBLPTRL,A
	; Erase this block
		BSF 	EECON1, EEPGD,A	; point to Flash program memory
		BCF 	EECON1, CFGS,A 	; access Flash program memory
		BSF 	EECON1, WREN,A 	; enable write to memory
		BSF 	EECON1, FREE,A 	; enable Row Erase operation
		BCF 	INTCON, GIE,A 	; disable interrupts
		MOVLW 	55h
		MOVWF 	EECON2,A	; write 55h
		MOVLW 	0AAh
		MOVWF 	EECON2,A	; write 0AAh
		BSF 	EECON1, WR,A 	; start erase (CPU stall)
		NOP
		BSF 	INTCON, GIE,A 	; re-enable interrupts
	; Write the buffer to holding reg
		TBLRD*- 				; dummy read decrement
WRITE_BUFFER_BACK
		MOVLW 	8 				; number of write buffer groups of 8 bytes
		MOVWF 	Breg,A
		MOVLR	HIGH AXreg
		MOVFP	AXreg+1,W 	; point to buffer
		MOVWF 	FSR1H,A
		MOVFP	AXreg,W
		MOVWF 	FSR1L,A
PROGRAM_LOOP
		MOVLW 	8 				; number of bytes in holding register
		MOVWF 	Creg,A
WRITE_WORD_TO_HREGS
		MOVFF 	POSTINC1, WREG 	; get low byte of buffer data
		MOVWF 	TABLAT,A		; present data to table latch
		TBLWT+* 				; write data, perform a short write
								; to internal TBLWT holding register.
		DECFSZ 	Creg,F,A 		; loop until buffers are full
		BRA 	WRITE_WORD_TO_HREGS
PROGRAM_MEMORY
		BSF 	EECON1, EEPGD,A	; point to Flash program memory
		BCF 	EECON1, CFGS,A 	; access Flash program memory
		BSF 	EECON1, WREN,A 	; enable write to memory
		BCF 	INTCON, GIE,A 	; disable interrupts
		MOVLW 	055h
		MOVWF 	EECON2,A		; write 55H
		MOVLW 	0AAh
		MOVWF 	EECON2,A		; write AAH
		BSF 	EECON1, WR,A	; start program (CPU stall)
		NOP
		BSF 	INTCON, GIE,A 	; re-enable interrupts
		DECFSZ 	Breg,F,A 		; loop until done
		BRA 	PROGRAM_LOOP
		BCF 	EECON1, WREN,A 	; disable write to memory
	; Advance pointers to next block
		MOVLR	HIGH CEXreg
		MOVLW	D'64'
		ADDWF	CEXreg
		MOVLW	0
		ADDWFC	CEXreg+1
		ADDWFC	CEXreg+2
		MOVLR	HIGH AXreg
		MOVLW	D'64'
		ADDWF	AXreg
		MOVLW	0
		ADDWFC	AXreg+1
	; Loop till all blocks are processed
		DECFSZ	Areg,F,A
		GOTO	FlashWrite_8720
		RETURN	


; Listed below are include statements for the two LCD display types 
; that are supported. Only include one of these files.
ifdef		LCD52display
	Include	<lcd52.asm>
endif
ifdef           SED1230display
	Include	<sed1230.asm>
endif
ifdef           ECMA1010display
	Include	<ECMA1010.asm>
endif


; This function sends the message pointed to by AXreg to the display.
; The full line is displayed, 12 or 16 characters depending on the 
; display type. The display line must be selected before this call 
; is made.
LCDsendAX
		MOVLW	LINE1
		CALL	LCDsendCMD
		MOVFF	AXreg,TBLPTRL
		MOVFF	AXreg+1,TBLPTRH
		CLRF	TBLPTRU,A
		CALL    LCDsendMess
		RETURN

; This function sends the message pointed to by AXreg line 2 of the display.
; The full line is displayed, 12 or 16 characters depending on the 
; display type.
LCDsendAXLine2
		MOVLW	LINE2
		CALL	LCDsendCMD
		MOVFF	AXreg,TBLPTRL
		MOVFF	AXreg+1,TBLPTRH
		CLRF	TBLPTRU,A
		CALL    LCDsendMess
		RETURN

; This function sends the message pointed to by DXreg line 2 of the display.
; The full line is displayed, 12 or 16 characters depending on the 
; display type.
LCDsendDXLine2
		MOVLW	LINE2
		CALL	LCDsendCMD
		MOVFF	DXreg,TBLPTRL
		MOVFF	DXreg+1,TBLPTRH
		CLRF	TBLPTRU,A
		CALL    LCDsendMess
		RETURN

; This function will send a message to the LCD display. This function sends
; the entire line, 16 characters or 12 characters depending on the display 
; type.
; The table pointers must point to the message in FLASH when this function
; is called.
; This function uses
;		WREG
;		Areg
;		Table pointers
LCDsendMess
ifdef   ECMA1010display
		MOVLW	0C
else
		MOVLW	10
endif
		GOTO	LCDsendMessN
		
; This function will send a message to the LCD display. This function sends
; the number of characters defined in WREG.
; The table pointers must point to the message in FLASH when this function
; is called.
; This function uses
;		WREG
;		Areg
;		Table pointers
LCDsendMessN
		MOVWF	Areg
NEXT
		TBLRD*+
		MOVFF	TABLAT,WREG
		IORWF	WREG
		BTFSC	ALUSTA,Z
		GOTO	DONE1
		CALL	LCDsendData
		DCFSNZ	Areg
		GOTO	DONE1
		TBLRD*+
		MOVFF	TABLAT,WREG
		IORWF	WREG
		BTFSC	ALUSTA,Z
		GOTO	DONE1
		CALL	LCDsendData
		DECFSZ	Areg
		GOTO	NEXT
DONE1	
		RETURN


; The function displays the value in the WREG on the display in
; binary format (1s and 0s). This value is displayed at the 
; current cursor location.
; Areg and Breg are used by this routine.
LCDbinary
		MOVWF	Areg
		MOVLW	D'8'
		MOVWF	Breg
LCDbinary0
		MOVLW	30
		BTFSC	Areg,7
		MOVLW	31
		CALL	LCDsendData
		RLCF	Areg
		DECFSZ	Breg
		GOTO	LCDbinary0
		RETURN

; The function displays the value in the WREG on the display in
; hex format. This value is displayed at the 
; current cursor location.
; Areg and Breg are used by this routine.
LCDhex
		MOVWF	Areg
		MOVLW	3A
		MOVWF	Breg
	; MS dibble
		MOVPF	Areg,WREG
		ANDLW	0F0
		RRNCF	WREG
		RRNCF	WREG
		RRNCF	WREG
		RRNCF	WREG
		IORLW	030
		CPFSGT	Breg
		ADDLW	7
		CALL	LCDsendData
	; LS dibble
		MOVPF	Areg,WREG
		ANDLW	0F
		IORLW	030
		CPFSGT	Breg
		ADDLW	7
		CALL	LCDsendData
		MOVPF	Areg,WREG
		RETURN

; This function prints the unsigned integer that is in 
; CEXreg to the LCD at the current position
LCDint
		CALL	Int2Str
		MOVFP	Buffer,WREG
		CALL	LCDsendData
LCDintA
		MOVFP	Buffer+1,WREG
		CALL	LCDsendData
LCDintB
		MOVFP	Buffer+2,WREG
		CALL	LCDsendData
LCDintC
		MOVFP	Buffer+3,WREG
		CALL	LCDsendData
LCDintD
		MOVFP	Buffer+4,WREG
		CALL	LCDsendData
		RETURN
LCDint4
		CALL	Int2Str
		GOTO	LCDintA
LCDint3
		CALL	Int2Str
		GOTO	LCDintB
LCDint2
		CALL	Int2Str
		GOTO	LCDintC
LCDint1
		CALL	Int2Str
		GOTO	LCDintD

LCDintZS
		CALL	Int2Str
		CALL	RemoveLeadingZeros
		MOVFP	Buffer,WREG
		CALL	LCDsendData
		MOVFP	Buffer+1,WREG
		CALL	LCDsendData
		MOVFP	Buffer+2,WREG
		CALL	LCDsendData
		MOVFP	Buffer+3,WREG
		CALL	LCDsendData
		MOVFP	Buffer+4,WREG
		CALL	LCDsendData
		RETURN

; This function removes leading zeros from the ascii string in Buffer.
RemoveLeadingZeros
		MOVLR	HIGH Buffer
		MOVLW	'0'
		CPFSEQ	Buffer
		RETURN
		MOVLW	' '
		MOVWF	Buffer

		MOVLW	'0'
		CPFSEQ	Buffer+1
		RETURN
		MOVLW	' '
		MOVWF	Buffer+1

		MOVLW	'0'
		CPFSEQ	Buffer+2
		RETURN
		MOVLW	' '
		MOVWF	Buffer+2

		MOVLW	'0'
		CPFSEQ	Buffer+3
		RETURN
		MOVLW	' '
		MOVWF	Buffer+3
		RETURN

; This function converts an integer into an ascii string.
; CEXreg contains the integer and the 5 byte
; string is placed in buffer
Int2Str
	; 10000 digit
		MOVLB	HIGH DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVLW	LOW D'10000'
		MOVWF	DEXreg
		MOVLW	HIGH D'10000'
		MOVWF	DEXreg+1
		CALL	Divide2416
		MOVLW	30
		IORWF	CEXreg,0
		MOVWF	Buffer
		MOVE	EEXreg,CEXreg
		MOVE	EEXreg+2,CEXreg+2
	; 1000 digit
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVLW	LOW D'1000'
		MOVWF	DEXreg
		MOVLW	HIGH D'1000'
		MOVWF	DEXreg+1
		CALL	Divide2416
		MOVLW	30
		IORWF	CEXreg,0
		MOVWF	Buffer+1
		MOVE	EEXreg,CEXreg
		MOVE	EEXreg+2,CEXreg+2
	; 100 digit
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVLW	LOW D'100'
		MOVWF	DEXreg
		MOVLW	HIGH D'100'
		MOVWF	DEXreg+1
		CALL	Divide2416
		MOVLW	30
		IORWF	CEXreg,0
		MOVWF	Buffer+2
		MOVE	EEXreg,CEXreg
		MOVE	EEXreg+2,CEXreg+2
	; 10 digit
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVLW	LOW D'10'
		MOVWF	DEXreg
		MOVLW	HIGH D'10'
		MOVWF	DEXreg+1
		CALL	Divide2416
		MOVLW	30
		IORWF	CEXreg,0
		MOVWF	Buffer+3
	; The 1's digit is in the remainder's lsb
		MOVLW	30
		IORWF	EEXreg,0
		MOVWF	Buffer+4
		RETURN

INCLUDE		<comms.asm>
INCLUDE		<FMS.asm>
INCLUDE		<Math.asm>


; This function is called in the run mode. When the Auto Trim and and Preset buttons
; are held down the throttle low point adjustment mode is entered. In this mode the
; elevator stick will adjust the throttle low value as long as the buttons are held.
; This function is called after the stick positions are read and normalized.
; Returns:
;	Z flag clear if not selected
;	Z flag set if mode is selected
ThrottleTrim
	; Test the buttons
		Pressed PORTD,PRESET
		BTFSC	ALUSTA,C
		GOTO	TTexit
		Pressed PORTE,AUTOT
		BTFSC	ALUSTA,C
		GOTO	TTexit
	; Here if the two buttons are pressed
		; If the throttle trim flag is not set then init the variables needed
		; and set the TTflag
		MOVLR	HIGH TTflag
		TSTFSZ	TTflag
		GOTO	TTinited
	; Here to set the flag and init the variables
		MOVLR	HIGH TTflag
		SETF	TTflag		
		; Convert throttle gains to uS
		MOVLR	HIGH TBH
		MOVE	TMH,AXreg
		MOVEC	D'1000',BXreg
		CALL	Mult1616
		MOVE	CEXreg+1,TTMH
		MOVLR	HIGH TBH
		MOVFP	TBH,WREG
		MOVLR	HIGH TTMH
		ADDWF	TTMH,F
		MOVLR	HIGH TBH
		MOVFP	TBH+1,WREG
		MOVLR	HIGH TTMH
		ADDWFC	TTMH+1,F
		MOVE	TBH,TTBH
TTinited
		; See if the Elevator stick indicates an adjustment	
		CALLF	Elevator	; C set for Up, Z set for Down
		BTFSC	ALUSTA,C
		GOTO	TTup
		BTFSS	ALUSTA,Z
		GOTO	TTgo
		; Here to decrease the low throttle position
		MOVLR	HIGH TTBH
		DECF	TTBH
		BTFSS	ALUSTA,C
		DECF	TTBH+1
		DECF	TTBH
		BTFSS	ALUSTA,C
		DECF	TTBH+1
		GOTO	TTgo		
		; Here to increase the low throttle position
TTup
		MOVLR	HIGH TTBH
		INCF	TTBH
		BTFSC	ALUSTA,Z
		INCF	TTBH+1
		INCF	TTBH
		BTFSC	ALUSTA,Z
		INCF	TTBH+1
		; Convert the throttle positions to gains
TTgo
		MOVE	TTMH,AXreg
		MOVLR	HIGH TTMH
		MOVFP	TTBH,WREG
		MOVLR	HIGH AXreg
		SUBWF	AXreg,F
		MOVLR	HIGH TTBH
		MOVFP	TTBH+1,WREG
		MOVLR	HIGH AXreg
		SUBWFB	AXreg+1,F
		MOVEC	D'256',BXreg
		CALL	Mult1616
		MOVEC	D'1000',DEXreg
		CALL	Divide2416
		MOVE	CEXreg,TMH
		MOVE	TTBH,TBH
		; Apply the trims and exit with the Z flag set
		CALL	ApplyTrims
		BSF	ALUSTA,Z
		RETURN
TTexit
	; Clear the Z flag and exit
		; If TTflag is set, save the throttle gains and clear the flag
		MOVLR	HIGH TTflag
		TSTFSZ	TTflag
		GOTO	TTsave
		; here if flag was clear so just exit now
		BCF	ALUSTA,Z
		RETURN
TTsave:
		; here to clear flag and save
		CLRF	TTflag
		CALL	SaveAircraftPage1
		; exit 
		BCF	ALUSTA,Z
		RETURN

; This function uses the generic parameter locations to calculate
; the joy stick position.
CenterNormalize
	; Is pos > center ?
		MOVLR	HIGH AXreg
		; AXreg = Pos - Ct
		MOVFP	Pos,W
		MOVPF	WREG,AXreg
		MOVFP	Pos+1,W
		MOVPF	WREG,AXreg+1
		MOVFP	Ct,W
		SUBWF	AXreg
		MOVFP	Ct+1,W
		SUBWFB	AXreg+1
		; If carry is set then Pos was less than Ct
		BTFSS	ALUSTA,C,A
		GOTO	CN1
	; If here then Pos >= Ct
		MOVFP	Gh,W
		MOVPF	WREG,BXreg
		MOVFP	Gh+1,W
		MOVPF	WREG,BXreg+1
		CALL	Mult1616
		; Get the ans divided by 256
		MOVFP	CEXreg+1,W
		MOVPF	WREG,Npos
		MOVFP	CEXreg+2,W
		MOVPF	WREG,Npos+1
		RETURN
	; If here then Pos < Ct
CN1
		MOVFP	Gl,W
		MOVPF	WREG,BXreg
		MOVFP	Gl+1,W
		MOVPF	WREG,BXreg+1
		CALL	Mult1616
		; Get the ans divided by 256
		MOVFP	CEXreg+1,W
		MOVPF	WREG,Npos
		MOVFP	CEXreg+2,W
		MOVPF	WREG,Npos+1
		RETURN

; This function is used to calculate the normalized position for a non
; centering input channel.
; 
; Inputs:
;	Pos = 16 bit variable containing the ADC counts
;	Ct  = 16 bit variable containing the offset
; 	Gh  = 16 bit variable containing the gain
; Outputs:
;	Npos = 16 bit variable containing the normailized result.
;	Npos = (Pos - Ct) * Gt / 256
NonCenterNormalize
	; AXreg = Pos - Ct
		MOVE	Pos,AXreg
		MOVF	Ct,W
		SUBWF	AXreg,F
		MOVF	Ct+1,W
		SUBWFB	AXreg+1,F
	; CEXreg = AXreg * Gh
		MOVE	Gh,BXreg
		CALL	Mult1616	; CEXreg = AXreg * BXreg
	; Npos = CEXreg/256
		MOVF	CEXreg+1,W
		MOVPF	WREG,Npos
		MOVF	CEXreg+2,W
		MOVPF	WREG,Npos+1
		RETURN
;
; This function will convert the raw ADC cound data into normalized
; joy stick position information. The centering channels and all trim
; channels are normalized to -1000 to +1000. The non centerning channels
; are normalized to 0 to 1000.
; The joy stick calibration parameters are used for this calculation.
;
; There are two version of this routine, one the the MicroPro upgrade
; and one for the PROLINE upgrade.
;
CalculateNormalizedPositions
	; Aielron
		MOVLW	ADCail
		CALL	ADCread
		MOVLW	ADCail
		CALL	OverSample
		; Move all parameters to normalized space
		MOVE	AHG,Gh
		MOVE	ACT,Ct
		MOVE	ALG,Gl
		; Normalize it!
		CALL	CenterNormalize
		MOVE	Npos,ATpos
		MOVE	Npos,Apos
	; Elevador
		MOVLW	ADCele
		CALL	ADCread
		MOVLW	ADCele
		CALL	OverSample
		; Move all parameters to normalized space
		MOVE	EHG,Gh
		MOVE	ECT,Ct
		MOVE	ELG,Gl
		; Normalize it!
		CALL	CenterNormalize
		MOVE	Npos,ETpos
		MOVE	Npos,Epos
	; Rudder
		MOVLW	ADCrud
		CALL	ADCread
		MOVLW	ADCrud
		CALL	OverSample
		; Move all parameters to normalized space
		MOVE	RHG,Gh
		MOVE	RCT,Ct
		MOVE	RLG,Gl
		; Normalize it!
		CALL	CenterNormalize
		MOVE	Npos,RTpos
		MOVE	Npos,Rpos
	; Throttle
		MOVLW	ADCthr
		CALL	ADCread
		MOVLW	ADCthr
		CALL	ADCread
		; Move all parameters to normalized space
		MOVE	THG,Gh
		MOVE	TCT,Ct
		; Normalize it!
		CALL	NonCenterNormalize
		MOVE	Npos,TTpos
		MOVE	Npos,Tpos
	; The PROLINE trims use the internal 5 volt ref and the battery for the pots,
	; so we need to reference them to the battery.
		MOVLW	ADCref
		CALL	ADCread
		; Save data in Vbat
		MOVLR	HIGH Vbat
		MOVLB	HIGH ADRESL
		MOVPF	ADRESL,WREG
		MOVPF	WREG,Vbat
		MOVPF	ADRESH,WREG
		MOVPF	WREG,Vbat+1
ifdef		PROLINE
	; Aielron trim
		MOVLW	ADCailTrim
		CALL	ADCread
		; Save data in AXreg
		MOVLR	HIGH AXreg
		MOVLB	HIGH ADRESL
		MOVPF	ADRESL,WREG
		MOVPF	WREG,AXreg
		MOVPF	ADRESH,WREG
		MOVPF	WREG,AXreg+1
		; Multiply by the Vbats nominal value
		CLRF	BXreg
		MOVLW	2
		MOVPF	WREG,BXreg+1
		CALL	Mult1616	; Result in CEXreg
		; Now divide by the actual Vbat value to correct for Vbat changes
		MOVLR	HIGH DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVE	Vbat,DEXreg
		CALL	Divide2416
		; Now normalize
		MOVE	AtrimCT,Ct
		MOVE	AtrimHG,Gh	
		MOVE	CEXreg,Pos
		CALL	NonCenterNormalize
		MOVE	Npos,Atrim
	; Elevator trim
		MOVLW	ADCeleTrim
		CALL	ADCread
		; Save data in AXreg
		MOVLR	HIGH AXreg
		MOVLB	HIGH ADRESL
		MOVPF	ADRESL,WREG
		MOVPF	WREG,AXreg
		MOVPF	ADRESH,WREG
		MOVPF	WREG,AXreg+1
		; Multiply by the Vbats nominal value
		CLRF	BXreg
		MOVLW	2
		MOVPF	WREG,BXreg+1
		CALL	Mult1616	; Result in CEXreg
		; Now divide by the actual Vbat value to correct for Vbat changes
		MOVLR	HIGH DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVE	Vbat,DEXreg
		CALL	Divide2416
		; Now normalize
		MOVE	EtrimCT,Ct
		MOVE	EtrimHG,Gh	
		MOVE	CEXreg,Pos
		CALL	NonCenterNormalize
		MOVE	Npos,Etrim
	; Rudder trim
		MOVLW	ADCrudTrim
		CALL	ADCread
		; Save data in AXreg
		MOVLR	HIGH AXreg
		MOVLB	HIGH ADRESL
		MOVPF	ADRESL,WREG
		MOVPF	WREG,AXreg
		MOVPF	ADRESH,WREG
		MOVPF	WREG,AXreg+1
		; Multiply by the Vbats nominal value
		CLRF	BXreg
		MOVLW	2
		MOVPF	WREG,BXreg+1
		CALL	Mult1616	; Result in CEXreg
		; Now divide by the actual Vbat value to correct for Vbat changes
		MOVLR	HIGH DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVE	Vbat,DEXreg
		CALL	Divide2416
		; Now normalize
		MOVE	RtrimCT,Ct
		MOVE	RtrimHG,Gh	
		MOVE	CEXreg,Pos
		CALL	NonCenterNormalize
		MOVE	Npos,Rtrim
	; Throttle trim
		MOVLW	ADCthrTrim
		CALL	ADCread
		; Save data in AXreg
		MOVLR	HIGH AXreg
		MOVLB	HIGH ADRESL
		MOVPF	ADRESL,WREG
		MOVPF	WREG,AXreg
		MOVPF	ADRESH,WREG
		MOVPF	WREG,AXreg+1
		; Multiply by the Vbats nominal value
		CLRF	BXreg
		MOVLW	2
		MOVPF	WREG,BXreg+1
		CALL	Mult1616	; Result in CEXreg
		; Now divide by the actual Vbat value to correct for Vbat changes
		MOVLR	HIGH DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVE	Vbat,DEXreg
		CALL	Divide2416
		; Now normalize
		MOVE	TtrimCT,Ct
		MOVE	TtrimHG,Gh	
		MOVE	CEXreg,Pos
		CALL	NonCenterNormalize
		MOVE	Npos,Ttrim
else
	; This section contains the normalization code for the trims found
	; on a MicroPro 8000

	; Aielron trim
		MOVLW	ADCailTrim
		CALL	ADCread
		; Now normalize
		MOVE	AtrimCT,Ct
		MOVE	AtrimHG,Gh	
		CALL	NonCenterNormalize
		MOVE	Npos,Atrim
	; Elevator trim
		MOVLW	ADCeleTrim
		CALL	ADCread
		; Now normalize
		MOVE	EtrimCT,Ct
		MOVE	EtrimHG,Gh	
		CALL	NonCenterNormalize
		MOVE	Npos,Etrim
	; Rudder trim
		MOVLW	ADCrudTrim
		CALL	ADCread
		; Now normalize
		MOVE	RtrimCT,Ct
		MOVE	RtrimHG,Gh	
		CALL	NonCenterNormalize
		MOVE	Npos,Rtrim
	; Throttle trim
		MOVLW	ADCthrTrim
		CALL	ADCread
		; Now normalize
		MOVE	TtrimCT,Ct
		MOVE	TtrimHG,Gh	
		CALL	NonCenterNormalize
		MOVE	Npos,Ttrim
endif
	; CH5, -1000 or 1000
		MOVLR	HIGH SWCH5
		MOVFP	SWCH5,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	CH5_OFF
		MOVEC	D'1000',CH5pos
		GOTO	CH5_Done
CH5_OFF
		MOVEC	0FC18,CH5pos		; -1000, stupid assembler!
CH5_Done
	; CH6
		MOVLW	ADCch6
		CALL	ADCread
		; Move all parameters to normalized space
		MOVE	CH6HG,Gh
		MOVE	CH6CT,Ct
		; Normalize it!
		CALL	NonCenterNormalize
		MOVE	Npos,CH6pos
	; CH7
		MOVLW	ADCch7
		CALL	ADCread
		; Move all parameters to normalized space
		MOVE	CH7HG,Gh
		MOVE	CH7CT,Ct
		; Normalize it!
		CALL	NonCenterNormalize
		MOVE	Npos,CH7pos
	; CH8, -1000, 0, or 1000
		MOVLR	HIGH SWCH8A
		MOVFP	SWCH8A,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	CH8_c
		MOVEC	D'1000',CH8pos
		GOTO	CH8_Done
CH8_c
		MOVLR	HIGH SWCH8C
		MOVFP	SWCH8C,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	CH8_b
		MOVEC	0FC18,CH8pos
		GOTO	CH8_Done
CH8_b
		MOVLR	HIGH SWCH8B
		MOVFP	SWCH8B,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	CH8_Done
		MOVEC	0,CH8pos
CH8_Done
		RETURN

;
; This function applies the expo to Aileron, Elevator and Rudder. There are
; two expo values for each channel. A high rate and low rate expo value.
; Below are the two expo functions:
;  High rate function (E = expo percentage)
;   Pos = Pos - (E * Pos/100 - E * Pos * Pos/100000)
;  Low rate function (E = expo percentage, G = low rate percentage)
;   Pos = Pos - (E * Pos/100 - E * Pos * Pos/(1000 * G))
;

; Generic function, assumes:
;	BXreg	=	Expo percentage
;	Breg	=	Channel gain
;	AXreg	=	Pos
; Result returned in AXreg
;
Expo:
	; Sign extend BXreg
		MOVLR	HIGH BXreg
		CLRF	BXreg+1
		BTFSC	BXreg,7
		COMF	BXreg+1
	; Calculate E * Pos/100
		CALL	Mult1616
		MOVEC	D'100',DEXreg
		CALL	Divide2416
	; CEXreg contains E * Pos/100
		MOVE	CEXreg,CXreg	; E * Pos/100 to CXreg
		MOVE	CEXreg,BXreg	; E * Pos/100 to BXreg
		; Because Pos*Pos will always be positive, we must take
		; the complement of Pos if its negative, make sense??
		BTFSS	AXreg+1,7
		GOTO	ExpoPos
		COMF	BXreg
		COMF	BXreg+1
		INCF	BXreg
		BTFSC	ALUSTA,C
		INCF	BXreg+1	
ExpoPos:
		CALL	Mult1616
		MOVEC	D'10',DEXreg
		CALL	Divide2416      ; ans in CEXreg
		MOVFP	Breg,WREG
		MOVPF	WREG,DEXreg
		CLRF	DEXreg+1	
		BTFSC	DEXreg,7
		COMF	DEXreg+1
		CALL	Divide2416      ; ans in CEXreg
	; Now wrap it up... do the additions...
		MOVFP	CXreg,WREG
		SUBWF	AXreg,F
		MOVFP	CXreg+1,WREG
		SUBWFB	AXreg+1,F
		MOVFP	CEXreg,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	AXreg+1,F
	; Done
		RETURN

		
; This function applies the generic expo function to all of the 
; channels, A,E, and R.
ApplyExpo:
	; Aileron expo
		; Test dual rate switch
		MOVLR	HIGH SWAILDR
		MOVFP	SWAILDR,WREG
		CALL	SwitchTest
		MOVE	Apos,AXreg
		BTFSS	ALUSTA,C
		GOTO	AEX1
		; Here if Low rate
		MOVLR	HIGH AEXLOW
		MOVFP	AEXLOW,WREG
		MOVLR	HIGH BXreg
		MOVPF	WREG,BXreg
		MOVLR	HIGH ALR
		MOVFP	ALR,WREG
		MOVPF	WREG,Breg
		GOTO	AEX1a
		; Here if high rate
AEX1:
		MOVLR	HIGH AEXHI
		MOVFP	AEXHI,WREG
		MOVLR	HIGH BXreg
		MOVPF	WREG,BXreg
		MOVLW	D'100'
		MOVPF	WREG,Breg
AEX1a:
		CALL	Expo
		MOVE	AXreg,Apos
	; Elevator expo
		; Test dual rate switch
		MOVLR	HIGH SWELEDR
		MOVFP	SWELEDR,WREG
		CALL	SwitchTest
		MOVE	Epos,AXreg
		BTFSS	ALUSTA,C
		GOTO	EEX1
		; Here if Low rate
		MOVLR	HIGH EEXLOW
		MOVFP	EEXLOW,WREG
		MOVLR	HIGH BXreg
		MOVPF	WREG,BXreg
		MOVLR	HIGH ELR
		MOVFP	ELR,WREG
		MOVPF	WREG,Breg
		GOTO	EEX1a
EEX1:
		; Here if high rate
		MOVLR	HIGH EEXHI
		MOVFP	EEXHI,WREG
		MOVLR	HIGH BXreg
		MOVPF	WREG,BXreg
		MOVLW	D'100'
		MOVPF	WREG,Breg
EEX1a:
		CALL	Expo
		MOVE	AXreg,Epos
	; Rudder expo
		; Test dual rate switch
		MOVLR	HIGH SWRUDDR
		MOVFP	SWRUDDR,WREG
		CALL	SwitchTest
		MOVE	Rpos,AXreg
		BTFSS	ALUSTA,C
		GOTO	REX1
		; Here if Low rate
		MOVLR	HIGH REXLOW
		MOVFP	REXLOW,WREG
		MOVLR	HIGH BXreg
		MOVPF	WREG,BXreg
		MOVLR	HIGH RLR
		MOVFP	RLR,WREG
		MOVPF	WREG,Breg
		GOTO	REX1a
REX1:
		; Here if high rate
		MOVLR	HIGH REXHI
		MOVFP	REXHI,WREG
		MOVLR	HIGH BXreg
		MOVPF	WREG,BXreg
		MOVLW	D'100'
		MOVPF	WREG,Breg
REX1a:
		CALL	Expo
		MOVE	AXreg,Rpos
		RETURN

;
; This function calculates the dual rate servo positions. Here is the math
; Pos = (G * Pos) /100
;
ApplyDualRates
	;
	; Aielron, Lin dual rate, Pos = (Pos * G)/100
	;
		MOVLR	HIGH SWAILDR
		MOVFP	SWAILDR,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	ADR1
		MOVE	Apos,BXreg
		MOVE	ALR,AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1
		CALL	Mult1616
		MOVEC	D'100',DEXreg
		CALL	Divide2416
		MOVE	CEXreg,Apos
	;
	; Elevador
	;
ADR1
		MOVLR	HIGH SWAILDR
		MOVFP	SWELEDR,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	ADR2
		MOVE	Epos,BXreg
		MOVE	ELR,AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1
		CALL	Mult1616
		MOVEC	D'100',DEXreg
		CALL	Divide2416
		MOVE	CEXreg,Epos
	;
	; Rudder
	;
ADR2
		MOVLR	HIGH SWAILDR
		MOVFP	SWRUDDR,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	ADR3
		MOVE	Rpos,BXreg
		MOVE	RLR,AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1
		CALL	Mult1616
		MOVEC	D'100',DEXreg
		CALL	Divide2416
		MOVE	CEXreg,Rpos
ADR3
		RETURN

ApplyTrims
	; Aielron
		MOVLR	HIGH AilTrimCh
		MOVFP	AilTrimCh,WREG
		CALL	SelectTrim			; Loads BXreg with trim value
		; Now add the trim zero values...
		MOVLR	HIGH TrimZeroAil
		MOVFP	TrimZeroAil,WREG
		MOVLR	HIGH BXreg
		ADDWF	BXreg
		MOVLR	HIGH TrimZeroAil
		MOVFP	TrimZeroAil+1,WREG
		MOVLR	HIGH BXreg
		ADDWFC	BXreg+1
		; 
		MOVE	APT,AXreg
		MOVLR	HIGH AXreg
		CLRF	AXreg+1
		MOVLW	0FF
		BTFSC	AXreg,7
		MOVWF	AXreg+1
		CALL	Mult1616
		MOVLR	HIGH DEXreg
		MOVLW	D'100'
		MOVWF	DEXreg
		CLRF	DEXreg+1
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416
		MOVLR	HIGH CEXreg
		; Autotrim...
		MOVLR	HIGH AAT
		MOVFP	AAT,WREG
		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1
		RLCF	AXreg			; Multiply by 2
		RLCF	AXreg+1
		MOVFP	AXreg,WREG
		ADDWF	CEXreg,F
		MOVFP	AXreg+1,WREG
		ADDWFC	CEXreg+1,F
		; End Autotrim...
		MOVFP	CEXreg,WREG
		ADDWF	Apos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Apos+1,F
	; Elevator
		MOVLR	HIGH EleTrimCh
		MOVFP	EleTrimCh,WREG
		CALL	SelectTrim
		; Now add the trim zero values...
		MOVLR	HIGH TrimZeroEle
		MOVFP	TrimZeroEle,WREG
		MOVLR	HIGH BXreg
		ADDWF	BXreg
		MOVLR	HIGH TrimZeroEle
		MOVFP	TrimZeroEle+1,WREG
		MOVLR	HIGH BXreg
		ADDWFC	BXreg+1
		; 
		MOVE	EPT,AXreg
		MOVLR	HIGH AXreg
		CLRF	AXreg+1
		MOVLW	0FF
		BTFSC	AXreg,7
		MOVWF	AXreg+1
		CALL	Mult1616
		MOVLR	HIGH DEXreg
		MOVLW	D'100'
		MOVWF	DEXreg
		CLRF	DEXreg+1
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416
		MOVLR	HIGH CEXreg
		; Autotrim...
		MOVLR	HIGH EAT
		MOVFP	EAT,WREG
		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1
		RLCF	AXreg			; Multiply by 2
		RLCF	AXreg+1
		MOVFP	AXreg,WREG
		ADDWF	CEXreg,F
		MOVFP	AXreg+1,WREG
		ADDWFC	CEXreg+1,F
		; End Autotrim...
		MOVFP	CEXreg,WREG
		ADDWF	Epos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Epos+1,F
	; Rudder
		MOVLR	HIGH RudTrimCh
		MOVFP	RudTrimCh,WREG
		CALL	SelectTrim
		; Now add the trim zero values...
		MOVLR	HIGH TrimZeroRud
		MOVFP	TrimZeroRud,WREG
		MOVLR	HIGH BXreg
		ADDWF	BXreg
		MOVLR	HIGH TrimZeroRud
		MOVFP	TrimZeroRud+1,WREG
		MOVLR	HIGH BXreg
		ADDWFC	BXreg+1
		; 
		MOVE	RPT,AXreg
		MOVLR	HIGH AXreg
		CLRF	AXreg+1
		MOVLW	0FF
		BTFSC	AXreg,7
		MOVWF	AXreg+1
		CALL	Mult1616
		MOVLR	HIGH DEXreg
		MOVLW	D'100'
		MOVWF	DEXreg
		CLRF	DEXreg+1
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416
		MOVLR	HIGH CEXreg
		; Autotrim...
		MOVLR	HIGH RAT
		MOVFP	RAT,WREG
		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1
		RLCF	AXreg			; Multiply by 2
		RLCF	AXreg+1
		MOVFP	AXreg,WREG
		ADDWF	CEXreg,F
		MOVFP	AXreg+1,WREG
		ADDWFC	CEXreg+1,F
		; End Autotrim...
		MOVFP	CEXreg,WREG
		ADDWF	Rpos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Rpos+1,F
	; Throttle, TMODE control out this trim is applied
	; 0 = normal
	; 1 = trim at low throttle only
	; 2 = trim at high throttle only
		; First calculate the trim...
		MOVLR	HIGH ThtTrimCh
		MOVFP	ThtTrimCh,WREG
		CALL	SelectTrim
		MOVE	TPT,AXreg
		MOVLR	HIGH AXreg
		CLRF	AXreg+1
		MOVLW	0FF
		BTFSC	AXreg,7
		MOVWF	AXreg+1
		CALL	Mult1616
		MOVLR	HIGH DEXreg
		MOVLW	D'100'
		MOVWF	DEXreg
		CLRF	DEXreg+1
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416	; Trim is now in CEXreg
		; Test the trim mode
		MOVLR	HIGH TMODE
		MOVLW	1
		CPFSEQ	TMODE
		GOTO	AT1
		; Here for mode 1, trim at low
		MOVLR	HIGH AXreg
		MOVLW	HIGH D'1000'
		MOVWF	AXreg+1
		MOVWF	DEXreg+1
		MOVLW	LOW D'1000'
		MOVWF	AXreg
		MOVWF	DEXreg
		MOVFP	Tpos,WREG
		SUBWF	AXreg,F
		MOVFP	Tpos+1,WREG
		SUBWFB	AXreg+1,F
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		MOVE	CEXreg,BXreg
		CALL	Mult1616
		CALL	Divide2416		
		GOTO	AT2
AT1
		MOVLW	2
		CPFSEQ	TMODE
		GOTO	AT2
		; Here for mode 2, trim at high
		MOVLR	HIGH AXreg
		MOVFP	Tpos,WREG
		MOVWF	AXreg
		MOVFP	Tpos+1,WREG
		MOVWF	AXreg+1
		MOVE	CEXreg,BXreg
		CALL	Mult1616
		MOVLR	HIGH DEXreg
		MOVLW	HIGH D'1000'
		MOVPF	WREG,DEXreg+1
		MOVLW	LOW D'1000'
		MOVPF	WREG,DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416		
AT2		; Apply the trim to the throttle position
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg,WREG
		ADDWF	Tpos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Tpos+1,F
		RETURN
		
ApplySubTrims
	; Add all the sub trim values to the position data
		; Aileron sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	Apos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Apos+1,F
		; Elevator sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+1,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	Epos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Epos+1,F
		; Rudder sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+2,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	Rpos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Rpos+1,F
		; Throttle sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+3,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	Tpos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Tpos+1,F
		; CH5 sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+4,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	CH5pos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	CH5pos+1,F
		; CH6 sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+5,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	CH6pos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	CH6pos+1,F
		; CH7 sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+6,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	CH7pos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	CH7pos+1,F
		; CH8 sub trim
		MOVLB	HIGH AXreg
		CLRF	AXreg+1
		MOVFF	SubTrim+7,AXreg
		BTFSC	AXreg,7
		SETF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVFP	CEXreg,WREG
		ADDWF	CH8pos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	CH8pos+1,F
		RETURN

ApplySnap
		MOVEC	D'10',AXreg
	; Snap right
	; Test the right snap button
		MOVLR	HIGH SWSNAPR
		MOVFP	SWSNAPR,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	AS10
		; If the MSB is clear then set the servo position
		MOVLR	HIGH SR_A
		BTFSS	SR_A+1,7
		GOTO	AS9a
		MOVEB	SR_A,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Apos		
AS9a		
		MOVLR	HIGH SR_E
		BTFSS	SR_E+1,7
		GOTO	AS9b
		MOVEB	SR_E,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Epos		
AS9b		
		MOVLR	HIGH SR_R
		BTFSS	SR_R+1,7
		GOTO	AS9c
		MOVEB	SR_R,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Rpos		
AS9c		
		MOVLR	HIGH SR_T
		BTFSS	SR_T+1,7
		GOTO	AS10
		MOVEB	SR_T,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Tpos		
AS10
	;  Snap left
		MOVLR	HIGH SWSNAPL
		MOVFP	SWSNAPL,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	AS11
		; If the MSB is clear then set the servo position
		MOVLR	HIGH SL_A
		BTFSS	SL_A+1,7
		GOTO	AS10a
		MOVEB	SL_A,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Apos		
AS10a		
		MOVLR	HIGH SL_E
		BTFSS	SL_E+1,7
		GOTO	AS10b
		MOVEB	SL_E,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Epos		
AS10b		
		MOVLR	HIGH SL_R
		BTFSS	SL_R+1,7
		GOTO	AS10c
		MOVEB	SL_R,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Rpos		
AS10c		
		MOVLR	HIGH SL_T
		BTFSS	SL_T+1,7
		GOTO	AS11
		MOVEB	SL_T,BXreg
		CLRF    BXreg+1
		BTFSC   BXreg,7
		SETF    BXreg+1
		CALL	Mult1616
		MOVE	CEXreg,Tpos		
AS11
        ; If Tpos is negative, set it to zero
                MOVLR   HIGH Tpos
                BTFSS   Tpos+1,7
                RETURN
                ; Here is Tpos is negative
                CLRF    WREG
                MOVWF   Tpos
                MOVWF   Tpos+1
                RETURN

; This function perfroms the auto trim algorithm. If the autotrim
; buttom is pressed and one of the centering stick is not 
; centered then the trim position is adjusted.
; There are two AutoTrim modes determined by ATmode.
; ATmode:
;        0 = Standard mode, while you hold the auto trim button the
;            channel is moved in small increments. You can define the
;            increment size and time between adjustments.
;        1 = One shot mode, in this mode the entire adjustment is made
;            in one step.
; The Auto Trim function will only allow a maximum of +- 20 percent adjustment
; of a channels position.
AutoTrim
	; If we are in the master mode then exit, do not
	; do auto trim in master mode!
		MOVLR	HIGH Master
		BTFSC	Master,0
		RETURN
	; Test the autotrim button
		MOVLR	HIGH SWATRIM
		MOVFP	SWATRIM,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		RETURN
	; Make sure its time...
		MOVLR	HIGH TimeOut2
		TSTFSZ	TimeOut2
		RETURN
		MOVLR	HIGH AutoTrimTime
		MOVFP	AutoTrimTime,WREG
		MOVLR	HIGH TimeOut2
		MOVWF	TimeOut2
		; Test if this is one shot mode
                MOVLR   HIGH ATmode
                MOVLW   1
                CPFSEQ  ATmode
                GOTO	AutoTrim0
		; Beep one time to indicate we are doing the adjustment
		MOVLW	D'1'  
		MOVLR	HIGH BeepCyl
		MOVWF	BeepCyl
		MOVLW	D'5'
		CALL	Beep
	        ; Set the one shot time, this is a fixed value
	        MOVLW   AutoTrimOStime	
		MOVLR	HIGH TimeOut2
		MOVWF	TimeOut2
AutoTrim0		
	; Aileron
		MOVE	Apos,AXreg
		CALL    AutoLimit
		BTFSS   ALUSTA,Z
		GOTO	AutoTrim2
		; Adjust autotrim position
		MOVLR   HIGH ATmode
		TSTFSZ  ATmode
		GOTO    AutoTrim1e
		MOVLR	HIGH AutoTrimStep
		MOVFP	AutoTrimStep,WREG
AutoTrim1e	MOVLR	HIGH Apos
		BTFSC	Apos+1,7
		GOTO	AutoTrim1a
		; Here if positive
		MOVLR	HIGH AAT
		ADDWF	AAT
		BTFSS	AAT,7
		GOTO	AutoTrim1c
		BTFSS	ALUSTA,OV
		GOTO	AutoTrim1c
		GOTO	AutoTrim1plim
AutoTrim1a	; Here if negative
		MOVLR	HIGH AAT
		SUBWF	AAT
		BTFSC	AAT,7
		GOTO	AutoTrim1c
		BTFSS	ALUSTA,OV
		GOTO	AutoTrim1c
		GOTO	AutoTrim1b
AutoTrim1c	; Now do the limit testing
		BTFSC	AAT,7
		GOTO	AutoTrim1b
		; Here if positive
AutoTrim1plim	MOVLW	D'100'
		CPFSLT	AAT
		MOVWF	AAT
		GOTO	AutoTrim1d
AutoTrim1b	; Here if negative
		MOVLW	D'100'
		COMF	WREG
		INCF	WREG
		CPFSGT	AAT
		MOVWF	AAT
		; Save the new value to Flash
AutoTrim1d
		CALL	SaveAircraftPage1
	; Elevator
AutoTrim2
		MOVE	Epos,AXreg
		CALL    AutoLimit
		BTFSS   ALUSTA,Z
		GOTO	AutoTrim3
		; Adjust autotrim position
		MOVLR   HIGH ATmode
		TSTFSZ  ATmode
		GOTO    AutoTrim2e
		MOVLR	HIGH AutoTrimStep
		MOVFP	AutoTrimStep,WREG
AutoTrim2e	MOVLR   HIGH Epos
		BTFSC	Epos+1,7
		GOTO	AutoTrim2a
		; Here if positive
		MOVLR	HIGH EAT
		ADDWF	EAT
		BTFSS	EAT,7
		GOTO	AutoTrim2c
		BTFSS	ALUSTA,OV
		GOTO	AutoTrim2c
		GOTO	AutoTrim2plim
AutoTrim2a	; Here if negative
		MOVLR	HIGH EAT
		SUBWF	EAT
		BTFSC	EAT,7
		GOTO	AutoTrim2c
		BTFSS	ALUSTA,OV
		GOTO	AutoTrim2c
		GOTO	AutoTrim2b
AutoTrim2c	; Now do the limit testing
		BTFSC	EAT,7
		GOTO	AutoTrim2b
		; Here is positive
AutoTrim2plim	MOVLW	D'100'
		CPFSLT	EAT
		MOVWF	EAT
		GOTO	AutoTrim2d
AutoTrim2b	; Here if negative
		MOVLW	D'100'
		COMF	WREG
		INCF	WREG
		CPFSGT	EAT
		MOVWF	EAT
		; Save the new value to Flash
AutoTrim2d
		CALL	SaveAircraftPage1
	; Rudder
AutoTrim3
		MOVE	Rpos,AXreg
		CALL    AutoLimit
		BTFSS   ALUSTA,Z
		GOTO	AutoTrim4
		; Adjust autotrim position
		MOVLR   HIGH ATmode
		TSTFSZ  ATmode
		GOTO    AutoTrim3e
		MOVLR	HIGH AutoTrimStep
		MOVFP	AutoTrimStep,WREG
AutoTrim3e	MOVLR   HIGH Rpos
		BTFSC	Rpos+1,7
		GOTO	AutoTrim3a
		; Here if positive
		MOVLR	HIGH RAT
		ADDWF	RAT
		BTFSS	RAT,7
		GOTO	AutoTrim3c
		BTFSS	ALUSTA,OV
		GOTO	AutoTrim3c
		GOTO	AutoTrim3plim
AutoTrim3a	; Here if negative
		MOVLR	HIGH RAT
		SUBWF	RAT
		BTFSC	RAT,7
		GOTO	AutoTrim3c
		BTFSS	ALUSTA,OV
		GOTO	AutoTrim3c
		GOTO	AutoTrim3b
AutoTrim3c	; Now do the limit testing
		BTFSC	RAT,7
		GOTO	AutoTrim3b
		; Here is positive
AutoTrim3plim	MOVLW	D'100'
		CPFSLT	RAT
		MOVWF	RAT
		GOTO	AutoTrim3d
AutoTrim3b	; Here if negative
		MOVLW	D'100'
		COMF	WREG
		INCF	WREG
		CPFSGT	RAT
		MOVWF	RAT
		; Save the new value to Flash
AutoTrim3d
		CALL	SaveAircraftPage1
AutoTrim4
		RETURN


; This function takes the absolute value of the number in reg AXreg and limits
; it to 200 (20 %). This function is used by the AutoTrim algorithm
; The channel's normalized position must be in AXreg. Additionally the position
; information is tested to see if its over threshold.
; Zero flag is set if the channel is above threshold.
; The limited value is returned in WREG divided by 2.
AutoLimit   
	; First determine the absolute value
		MOVLB	HIGH AXreg
		BTFSS	AXreg+1,7
		GOTO	AutoLimit1
		COMF	AXreg
		COMF	AXreg+1
		INCF	AXreg
		BTFSC	ALUSTA,C
		INCF	AXreg+1
	; Now determine if its over 100
AutoLimit1
		; Divide by 2
		BCF	ALUSTA,C
                RRCF    AXreg+1
                RRCF    AXreg
		; Limit test		
		TSTFSZ	AXreg+1
		GOTO	AutoLimit3
		MOVLW	D'100'
		CPFSGT	AXreg
		GOTO    AutoLimit2
	; Set limit to 100
AutoLimit3	MOVEC	D'100',AXreg
	; Test Threshold
AutoLimit2
                ; Divide by 4
                MOVF    AXreg,W
                RRCF    WREG
                RRCF    WREG
                ANDLW   01F
                BTG     ALUSTA,Z
                MOVFF   AXreg,WREG                
                RETURN

;
; This function uses the normalized servo position and the selected aircraft's
; setup information to calculate the servo positions and place the results
; in the timing array. If the dual aileron mixer mode is enabled then channel
; 7 will use the aileron channel gains.
;
CalculateServoPositions
	; Clear OVERRUN flag
		MOVLR	HIGH OVERRUN
		CLRF	OVERRUN
	; Aielron
		MOVLR	HIGH Apos
		BTFSC	Apos+1,7
		GOTO	CSP1
		; Here if positive
		MOVE	AM1H,AXreg
		MOVE	Apos,BXreg
		CALL	Mult1616
		GOTO	CSP2

CSP1		; Here if negative
		MOVE	AM2H,AXreg
		MOVE	Apos,BXreg
		CALL	Mult1616
CSP2
		; Add the offset
		MOVE	AB,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
		CALL    ApplyLimit
		MOVE	AXreg,chAIL
	; Elevator
		MOVLR	HIGH Epos
		BTFSC	Epos+1,7
		GOTO	CSP3
		; Here if positive
		MOVE	EM1H,AXreg
		MOVE	Epos,BXreg
		CALL	Mult1616
		GOTO	CSP4

CSP3		; Here if negative
		MOVE	EM2H,AXreg
		MOVE	Epos,BXreg
		CALL	Mult1616
CSP4
		; Add the offset
		MOVE	EB,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
		CALL    ApplyLimit
		MOVE	AXreg,chELE
	; Rudder
		MOVLR	HIGH Rpos
		BTFSC	Rpos+1,7
		GOTO	CSP5
		; Here if positive
		MOVE	RM1H,AXreg
		MOVE	Rpos,BXreg
		CALL	Mult1616
		GOTO	CSP6

CSP5		; Here if negative
		MOVE	RM2H,AXreg
		MOVE	Rpos,BXreg
		CALL	Mult1616
CSP6
		; Add the offset
		MOVE	RB,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
		CALL    ApplyLimit
		MOVE	AXreg,chRUD
	; Throttle
		MOVE	TMH,AXreg
		MOVE	Tpos,BXreg
		CALL	Mult1616
		MOVE	TBH,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
		CALL    ApplyLimit
		MOVE	AXreg,chTHT
	; CH5	
		MOVE	CH5MH,AXreg
		MOVE	CH5pos,BXreg
		CALL	Mult1616
		MOVE	CH5BH,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
		CALL    ApplyLimit
		MOVE	AXreg,chCH5
	; CH6
	; Test if the dual elevator mixer flag is set...
;		MOVLR	HIGH DualE
;		BTFSS	DualE,0		
		GOTO	CH6normal
	; Here if the dual elevator flag is set
		MOVLR	HIGH CH6pos
		BTFSC	CH6pos+1,7
		GOTO	CSP1b
		; Here if positive
		MOVE	EM1H,AXreg
		MOVE	CH6pos,BXreg
		CALL	Mult1616
		GOTO	CSP2b

CSP1b		; Here if negative
		MOVE	EM2H,AXreg
		MOVE	CH6pos,BXreg
		CALL	Mult1616
CSP2b
		; Add the offset
		MOVE	EB,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		GOTO	CH6save
	; Here if the dual elevator flag is clear
CH6normal
		MOVE	CH6MH,AXreg
		MOVE	CH6pos,BXreg
		CALL	Mult1616
		MOVE	CH6BH,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
CH6save
		CALL    ApplyLimit
		MOVE	AXreg,chCH6
	; CH7
	; Test if the dual aileron mixer flag is set...
;		MOVLR	HIGH DUALA
;		BTFSS	DUALA,0		
		GOTO	CH7normal
	; Here if the dual aileron flag is set
		MOVLR	HIGH CH7pos
		BTFSC	CH7pos+1,7
		GOTO	CSP1a
		; Here if positive
		MOVE	AM1H,AXreg
		MOVE	CH7pos,BXreg
		CALL	Mult1616
		GOTO	CSP2a

CSP1a		; Here if negative
		MOVE	AM2H,AXreg
		MOVE	CH7pos,BXreg
		CALL	Mult1616
CSP2a
		; Add the offset
		MOVE	AB,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		GOTO	CH7save
	; Here if the dual aileron flag is clear
CH7normal
		MOVE	CH7MH,AXreg
		MOVE	CH7pos,BXreg
		CALL	Mult1616
		MOVE	CH7BH,AXreg
		MOVLR	HIGH AXreg
		MOVFP	CEXreg+1,WREG
		ADDWF	AXreg,F
		MOVFP	CEXreg+2,WREG
		ADDWFC	AXreg+1,F
		; Place in output timing array
CH7save
		CALL    ApplyLimit
		MOVE	AXreg,chCH7
	; CH8
		MOVE	CH8pos,AXreg
		; Test the sign
		BTFSC	AXreg+1,7
		GOTO	CSP7
		; Here if postive
		MOVE	CH8_A,BXreg
		CALL	Mult1616
		GOTO	CSP8		
CSP7		; Here if negative
		MOVE	CH8_C,BXreg
		CALL	Mult1616
CSP8		; Add the offset term...
		MOVE	CH8_B,AXreg
		MOVFP	AXreg,WREG
		ADDWF	CEXreg+1,F
		MOVFP	AXreg+1,WREG
		ADDWFC	CEXreg+2,F
		MOVE    CEXreg+1,AXreg
		CALL    ApplyLimit
		MOVE	AXreg,chCH8
	; Now proccess all of the buttons:
	;  Throttle preset
		MOVLR	HIGH TTflag		; If the throttle trim adjust flag is set then
		TSTFSZ	TTflag			; ignore the preset button test.
		GOTO	CSP9
		MOVLR	HIGH SWPRESET
		MOVFP	SWPRESET,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	CSP9
		MOVE	Tpreset,chTHT
CSP9
		RETURN
	
; This function will test the value in AXreg using the variables in
; ServoMin and ServoMax. If the value in AXreg exceeds the limts, AXreg
; will be set to limit.	
ApplyLimit
        ; Test the minimum limit by subtrating it from the servo position
                MOVLR   HIGH ServoMin
                MOVFP   ServoMin,WREG
                MOVLR   HIGH AXreg
                SUBWF   AXreg,W
                MOVLR   HIGH ServoMin
                MOVFP   ServoMin+1,WREG
                MOVLR   HIGH AXreg
                SUBWFB  AXreg+1,W
         ; If its negative then its below the minimum limit
                BTFSS   WREG,7
                GOTO    AL1
                ; Here is negative, so set to minimum and exit
                MOVE    ServoMin,AXreg
                RETURN                
        ; Test the maximum limit by subtracting the maximum from the servo position
AL1
                MOVLR   HIGH ServoMax
                MOVFP   ServoMax,WREG
                MOVLR   HIGH AXreg
                SUBWF   AXreg,W
                MOVLR   HIGH ServoMax
                MOVFP   ServoMax+1,WREG
                MOVLR   HIGH AXreg
                SUBWFB  AXreg+1,W
         ; If its negative then its below the minimum limit
                BTFSC   WREG,7
                RETURN
                ; Here is negative, so set to minimum and exit
                MOVE    ServoMax,AXreg
                RETURN


; This function tests the Option button and returns its state
; in the carry flag.
;	C set if Option button was pressed
Option
		MOVLR	HIGH PORTEimage
		BTFSC	PORTEimage,OPTION
		GOTO	Option1
		; Test if its been processed
		BTFSS	PORTElatch,OPTION
		GOTO	Option1
		; Beep one time to indicate we detected the
		; button...
		BCF	PORTElatch,OPTION
		MOVLW	D'1'
		MOVWF	BeepCyl
		MOVLW	D'5'
		CALL	Beep
		BSF	ALUSTA,C,A
		RETURN
Option1
		BCF	ALUSTA,C,A
		RETURN

; This function will load the general setup data from Flash into bank 2
; This data applies to all aircraft and includes the joy stick calibration
; parameters.
LoadGeneral
	; Setup variables...
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		MOVEC	200,AXreg
		MOVEC24	ConfigLoc,CEXreg
		CLRF	WREG,A
		MOVWF	Areg,A
	
		CALL	FlashRead	; Read the data
		; Load Aircraft number into current aircraft
		MOVLR	HIGH Aircraft
		MOVFP	Aircraft,W
		MOVLR	HIGH DefaultAircraft
		MOVWF	DefaultAircraft
		RETURN

; Writes the general parameters to Flash
SaveGeneral
	; Setup variables...
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		MOVEC	200,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVLW	4
		MOVWF	Areg,A
		CALL	FlashWrite	; Read the data
		RETURN
		
; This function loads just the aircraft name for the current aircraft
; number defined in WREG.
LoadAircraftName
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		; Convert aircraft number to page pointer into config area
		RLNCF	WREG
		DECF	WREG
		MOVWF	Breg,A		; Save page pointer
	; Load 16 bytes
		MOVEC	300,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVF	Breg,W,A
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVLW	D'16'
		MOVWF	Areg,A
		CALL	FlashRead
		RETURN

; This function saves the Name (16 bytes) in the aircraft number defined in 
; WREG. The first 64 bytes of the selected aircraft is copied to ram block 8
; and then the Name is updated and copied back to flash.
SaveAircraftName
	; First read the first 64 bytes (1 page) of the selected aircraft
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		; Convert aircraft number to page pointer into config area
		RLNCF	WREG
		DECF	WREG
		MOVWF	Breg,A		; Save page pointer
		
		MOVEC	800,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Breg,W,A
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVLW	D'64'
		MOVWF	Areg,A
	
		CALL	FlashRead
	; Now update the Name
		MOVEC	Name, Src
		MOVEC	Name, Dst
		MOVLR	HIGH Dst
		MOVLW	8		; Block 8
		MOVWF	Dst+1
		MOVLW	D'16'
		MOVWF	Cnt
		CALL	BlkMove
	; Write back to flash aircraft number
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		MOVEC	800,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Breg,W,A
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVLW	1
		MOVWF	Areg,A
	
		CALL	FlashWrite	; Read the data
		RETURN

; This function will load the aircraft data from Flash memory.
; 	WERG = Aircraft number
LoadAircraft
	; Setup variables...
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		; Convert aircraft number to page pointer into config area
		RLNCF	WREG
		DECF	WREG
		MOVWF	Breg,A		; Save page pointer
	; Read first page		
		MOVEC	300,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Breg,W,A
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVWF	Areg,A
		CALL	FlashRead	; Read the data
	; Read second page		
		MOVEC	400,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Breg,W,A
		INCF	WREG
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVWF	Areg,A
		CALL	FlashRead	; Read the data
		RETURN
; 	WERG = Aircraft number
SaveAircraft
	; Setup variables...
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		; Convert aircraft number to page pointer into config area
		RLNCF	WREG
		DECF	WREG
		MOVWF	Creg,A		; Save Page pointer
	; Save first page
		MOVEC	300,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Creg,W,A
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVLW	4
		MOVWF	Areg,A
		CALL	FlashWrite	; Read the data
	; Save second page
		MOVEC	400,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Creg,W,A
		INCF	WREG
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVLW	4
		MOVWF	Areg,A
		CALL	FlashWrite	; Read the data		
		RETURN
		
; This function copies the airvraft setup data stored in page 3 and 4 to its backup
; location in page 6 and 7. This backup data is used for the alternate aircraft function.
BackupAircraft
		MOVEC	300, Src
		MOVEC	600, Dst
		MOVLW	0
		MOVWF	Cnt
		CALL	BlkMove

		MOVEC	400, Src
		MOVEC	700, Dst
		MOVLW	0
		MOVWF	Cnt
		CALL	BlkMove
		RETURN
		
; This functions saves the first page (64 bytes) of the aircraft configuration
; data to flash memory. The Aircraft number is used for the storage location.
SaveAircraftPage1
	; Setup variables...
	;   AXreg  = Destination address in ram
	;   CEXreg = Flash memory address 
	;   Areg   = Number of bytes to read
		MOVLR	HIGH Aircraft
		MOVFP	Aircraft,W
		; Convert aircraft number to page pointer into config area
		RLNCF	WREG
		DECF	WREG
		MOVWF	Areg,A		; Save page pointer
		
		MOVEC	300,AXreg
		MOVEC24	ConfigLoc,CEXreg
		MOVFP	Areg,W,A
		ADDWF	CEXreg+1
		CLRF	WREG,A
		ADDWFC	CEXreg+2
		MOVLW	1
		MOVWF	Areg,A
	
		CALL	FlashWrite	; Read the data
		RETURN

;
; Mixer routines...
;
; This routine will move all of the channel position data to the Mixed
; position variables.
Move2Mix
		MOVE16	Apos,AposM
		MOVE16	Epos,EposM
		MOVE16	Rpos,RposM
		MOVE16	Tpos,TposM
		MOVE16	CH5pos,CH5posM
		MOVE16	CH6pos,CH6posM
		MOVE16	CH7pos,CH7posM
		MOVE16	CH8pos,CH8posM
		RETURN

; This function applies the mixers to all servo channels. The mixer switch
; position are tested and if on the mixers are applied. The preprogramed mix
; function are not applied by the routine
ApplyMixers
		CALL	Move2Mix
	; Test Mixer 1
		MOVLR	HIGH SWMIX1
		MOVFP	SWMIX1,WREG
		CALL	SwitchTest
		BTFSC	ALUSTA,C
		GOTO	APmix2
		; Apply all four mix channels
		MOVLW	HIGH M1Afrom
		MOVWF	FSR1H,A
		MOVLW	LOW M1Afrom
		MOVWF	FSR1L,A
		CALL	Mixer
		MOVLW	LOW M1Bfrom
		MOVWF	FSR1L,A
		CALL	Mixer
		MOVLW	LOW M1Cfrom
		MOVWF	FSR1L,A
		CALL	Mixer
		MOVLW	LOW M1Dfrom
		MOVWF	FSR1L,A
		CALL	Mixer
APmix2
		CALL	Move2Mix
		MOVLR	HIGH SWMIX2
		MOVFP	SWMIX2,WREG
		CALL	SwitchTest
		BTFSC	ALUSTA,C
		GOTO	APmix3
		MOVLW	HIGH M2Afrom
		MOVWF	FSR1H,A
		MOVLW	LOW M2Afrom
		MOVWF	FSR1L,A
		CALL	Mixer
		CALL	Move2Mix
		MOVLW	LOW M2Bfrom
		MOVWF	FSR1L,A
		CALL	Mixer
		CALL	Move2Mix
		MOVLW	LOW M2Cfrom
		MOVWF	FSR1L,A
		CALL	Mixer
		CALL	Move2Mix
		MOVLW	LOW M2Dfrom
		MOVWF	FSR1L,A
		CALL	Mixer
APmix3
		CALL	Move2Mix
		MOVLR	HIGH SWMIX3
		MOVFP	SWMIX3,WREG
		CALL	SwitchTest
		BTFSC	ALUSTA,C
		GOTO	APdone
		MOVLW	HIGH M3Afrom
		MOVWF	FSR1H,A
		MOVLW	LOW M3Afrom
		MOVWF	FSR1L,A
		CALL	Mixer
		MOVLW	LOW M3Bfrom
		MOVWF	FSR1L,A
		CALL	Mixer
		MOVLW	LOW M3Cfrom
		MOVWF	FSR1L,A
		CALL	Mixer
		MOVLW	LOW M3Dfrom
		MOVWF	FSR1L,A
		CALL	Mixer
APdone
		RETURN

; This function calculates the fixed mixer functions:
;	Aileron to rudder
;	Rudder to aileron
;	Rudder to elevator
;	Throttle to elevator
; After these functions are performed the mixer
; position array data is copied back to the input
; position array. 
;	Dual elevator
;	VTAIL		Rudder and Elevator mix
;	ELEVON		Aileron and Elevator mix
;	DUALA		Dual aileron
; It is assumed the position variables have been copied to 
; the mixer array. The information is calculated using the
; mixer array as the source and the standard array as the 
; destination.
CalculateFixedMixers
	; Aileron to rudder mix
		MOVE	AposM,AXreg		; Load position data
		MOVFF	AilRudPos,BXreg		; Load positive mix level as default
		MOVLB	HIGH BXreg
		BTFSC	AXreg+1,7
		MOVFF	AilRudNeg,BXreg		; If pos is neg, load neg gain
		CLRF	BXreg+1
		BTFSC	BXreg,7
		SETF	BXreg+1			; Sign extend
		CALL	Mult1616		; CEXreg = AXreg * BXreg
		MOVEC	D'100',DEXreg
		CALL	Divide2416		; CEXreg = CEXreg / DEXreg
		; Add mix level in CEXreg to rudder position
		MOVLB	HIGH RposM
		MOVFF	CEXreg,WREG
		ADDWF	RposM
		MOVFF	CEXreg+1,WREG
		ADDWFC	RposM+1
	; Rudder to aileron mix
		MOVE	RposM,AXreg		; Load position data
		MOVFF	RudAilPos,BXreg		; Load positive mix level as default
		MOVLB	HIGH BXreg
		BTFSC	AXreg+1,7
		MOVFF	RudAilNeg,BXreg		; If pos is neg, load neg gain
		CLRF	BXreg+1
		BTFSC	BXreg,7
		SETF	BXreg+1			; Sign extend
		CALL	Mult1616		; CEXreg = AXreg * BXreg
		MOVEC	D'100',DEXreg
		CALL	Divide2416		; CEXreg = CEXreg / DEXreg
		; Add mix level in CEXreg to aileron position
		MOVLB	HIGH AposM
		MOVFF	CEXreg,WREG
		ADDWF	AposM
		MOVFF	CEXreg+1,WREG
		ADDWFC	AposM+1
	; Rudder to elevator mix
		MOVE	RposM,AXreg		; Load position data
		MOVFF	RudElePos,BXreg		; Load positive mix level as default
		MOVLB	HIGH BXreg
		BTFSC	AXreg+1,7
		MOVFF	RudEleNeg,BXreg		; If pos is neg, load neg gain
		CLRF	BXreg+1
		BTFSC	BXreg,7
		SETF	BXreg+1			; Sign extend
		CALL	Mult1616		; CEXreg = AXreg * BXreg
		MOVEC	D'100',DEXreg
		CALL	Divide2416		; CEXreg = CEXreg / DEXreg
		; Add mix level in CEXreg to elevator position
		MOVLB	HIGH EposM
		MOVFF	CEXreg,WREG
		ADDWF	EposM
		MOVFF	CEXreg+1,WREG
		ADDWFC	EposM+1
	; Throttle to elevator mix
		MOVE	TposM,AXreg		; Load position data
		MOVFF	ThtEle,BXreg		; Load mix level
		MOVLB	HIGH BXreg
		BTFSC	AXreg+1,7
		CLRF	BXreg+1
		BTFSC	BXreg,7
		SETF	BXreg+1			; Sign extend
		CALL	Mult1616		; CEXreg = AXreg * BXreg
		MOVEC	D'100',DEXreg
		CALL	Divide2416		; CEXreg = CEXreg / DEXreg
		; Add mix level in CEXreg to elevator position
		MOVLB	HIGH EposM
		MOVFF	CEXreg,WREG
		ADDWF	EposM
		MOVFF	CEXreg+1,WREG
		ADDWFC	EposM+1	
	; Copy the mix results to the position array
		MOVE	AposM,Apos
		MOVE	EposM,Epos
		MOVE	RposM,Rpos
		MOVE	TposM,Tpos
	; Dual Elevator mixing function. Use CH6 for the second elevator
		MOVLR	HIGH DualE
		BTFSS	DualE,0
		GOTO	AFM0z
		; Here if dual elevator mixing is enabled
		MOVE	EposM,CH6pos
		; If CH6 reverse flag is set then reverse the CH6 polarity here
		MOVLR	HIGH RevE
		BTFSS	RevE,0
		GOTO	AFM0z
		; Here if CH6 needs to be reversed
		MOVLR	HIGH CH6pos
		COMF	CH6pos
		COMF	CH6pos+1
		INCF	CH6pos
		BTFSC	ALUSTA,C
		INCF	CH6pos+1
AFM0z	
	; VTAIL mixing, VTAIL flag is 0 if off
	;    Rudder   = Elevator/2 + Rudder/2
	;    Elevator = Elevator/2 - Rudder/2
		MOVLR	HIGH VTAIL
		BTFSS	VTAIL,0
		GOTO	AFM1
		; Here if the Vtail is enabled.
		MOVE	EposM,AXreg
		MOVE	RposM,BXreg
		MOVLR	HIGH AXreg
		; AXreg = Axreg/2
;		BCF	ALUSTA,C			; Removed 4/6/06
;		BTFSC	AXreg+1,7
;		BSF	ALUSTA,C
;		RRCF	AXreg+1
;		RRCF	AXreg
		; BXreg = BXreg/2
;		BCF	ALUSTA,C
;		BTFSC	BXreg+1,7
;		BSF	ALUSTA,C
;		RRCF	BXreg+1
;		RRCF	BXreg
		; Do the math...
		MOVE	AXreg,Epos
		MOVE	AXreg,Rpos
		MOVFP	BXreg,WREG
		ADDWF	Rpos
		MOVFP	BXreg+1,WREG
		ADDWFC	Rpos+1
		MOVFP	BXreg,WREG
		SUBWF	Epos
		MOVFP	BXreg+1,WREG
		SUBWFB	Epos+1
	; ELEVON mixing, ELEVON flag is 0 if off
	;    Aileron  = Elevator/2 + Aileron/2
	;    Elevator = Elevator/2 - Aileron/2
AFM1
		MOVLR	HIGH ELEVON
		BTFSS	ELEVON,0
		GOTO	AFM2
		; Here if the ELEVON is enabled.
		MOVE	EposM,AXreg
		MOVE	AposM,BXreg
		MOVLR	HIGH AXreg
		; AXreg = Axreg/2			; Removed 4/6/06
;		BCF	ALUSTA,C
;		BTFSC	AXreg+1,7
;		BSF	ALUSTA,C
;		RRCF	AXreg+1
;		RRCF	AXreg
		; BXreg = BXreg/2
;		BCF	ALUSTA,C
;		BTFSC	BXreg+1,7
;		BSF	ALUSTA,C
;		RRCF	BXreg+1
;		RRCF	BXreg
		; Do the math...
		MOVE	AXreg,Epos
		MOVE	AXreg,Apos
		MOVFP	BXreg,WREG
		ADDWF	Apos
		MOVFP	BXreg+1,WREG
		ADDWFC	Apos+1
		MOVFP	BXreg,WREG
		SUBWF	Epos
		MOVFP	BXreg+1,WREG
		SUBWFB	Epos+1
	; DUALA, dual aileron mixing. CH7 used for second
	; aileron channel, if REVA flag is non zero then channel
	; 7 is reversed.
AFM2
		MOVLR	HIGH DUALA
		BTFSS	DUALA,0
		GOTO	AFM3
		; Here if the DUALA is enabled.
		MOVE	AposM,AXreg
		MOVE	AXreg,Apos
		MOVE	AXreg,CH7pos
		; Apply the diferential.
		MOVEC	D'100',DEXreg
		MOVLR	HIGH DIFFA
		MOVFP	DIFFA,WREG
		IORWF	WREG
		BTFSC	ALUSTA,Z
		GOTO	AFM2a
		; If the percentage is positive then apply to positive servo 
		; position, if negative apply to negative servo positions.
		BTFSC	WREG,7
		GOTO	AFM2b
		; Here if positive
		SUBLW	D'100'		; WREG = 100 - DIFFA
		MOVLR	HIGH Apos
		MOVWF	BXreg
		CLRF	BXreg+1
		BTFSC	Apos+1,7
		GOTO	AFM2c
		MOVE	Apos,AXreg
		CALL	Mult1616	; CEXreg = AXreg * BXreg
		CALL	Divide2416
		MOVE	CEXreg,Apos
		GOTO	AFM2a
AFM2c
		MOVLR	HIGH CH7pos
		MOVE	CH7pos,AXreg
		CALL	Mult1616	; CEXreg = AXreg * BXreg
		CALL	Divide2416
		MOVE	CEXreg,CH7pos
		GOTO	AFM2a
AFM2b		; Here if negative
		ADDLW	D'100'		; WREG = 100 + DIFFA
		MOVLR	HIGH Apos
		MOVWF	BXreg
		CLRF	BXreg+1
		BTFSS	Apos+1,7
		GOTO	AFM2d
		MOVE	Apos,AXreg
		CALL	Mult1616	; CEXreg = AXreg * BXreg
		CALL	Divide2416
		MOVE	CEXreg,Apos
		GOTO	AFM2a
AFM2d
		MOVLR	HIGH CH7pos
		MOVE	CH7pos,AXreg
		CALL	Mult1616	; CEXreg = AXreg * BXreg
		CALL	Divide2416
		MOVE	CEXreg,CH7pos
AFM2a
		; If CH7 reverse flag is set then reverse the CH7 polarity here
		MOVLR	HIGH REVA
		BTFSS	REVA,0
		GOTO	AFM2z
		; Here if CH7 needs to be reversed
		MOVLR	HIGH CH7pos
		COMF	CH7pos
		COMF	CH7pos+1
		INCF	CH7pos
		BTFSC	ALUSTA,C
		INCF	CH7pos+1
AFM2z	
		; Apply flapperrons if enabled
		; Use the old CH7pos signal as the flap control.
		; (1000 + CH7pos)/2 * FPgain / 100
		MOVEC	D'100',DEXreg
		MOVLR	HIGH FPgain
		MOVFP	FPgain,WREG
		IORWF	WREG
		BTFSC	ALUSTA,Z
		GOTO	AFM2e           ; If gain is 0 then its disabled so jump out
		; If CROW is enabled and CROW switch is OFF then jump out
		MOVLR	HIGH CROWENA    ; Test for CROW enable...
		MOVFP	CROWENA,WREG
		IORWF	WREG
		BTFSC	ALUSTA,Z
		GOTO    AFM2aa          ; Jump if CROW is disabled
		MOVLR	HIGH SWCROW
		MOVFP	SWCROW,WREG
		CALL	SwitchTest
		BTFSC	ALUSTA,C
		GOTO	AFM2e           ; Jump out if CROW switch is off
		MOVEC	D'1000',AXreg
		MOVFP	TposM,WREG
		SUBWF	AXreg,F
		MOVFP	TposM+1,WREG
		SUBWFB	AXreg+1,F	; AXreg = 1000 - TposM
                GOTO    AFM2aaa
		; Here to apply the flap, first calculate the position
AFM2aa		MOVEC	D'1000',AXreg
		MOVFP	CH7posM,WREG
		ADDWF	AXreg,F
		MOVFP	CH7posM+1,WREG
		ADDWFC	AXreg+1,F	; AXreg = 1000 + CH7posM
		BCF	ALUSTA,C	; Clear carry
		RRCF	AXreg+1,F
		RRCF	AXreg,F		; AXreg = (1000 + CH7posM)/2
AFM2aaa		MOVE	FPgain,BXreg
		CLRF	BXreg+1
		BTFSC	BXreg,7
		COMF	BXreg+1
		CALL	Mult1616
		CALL	Divide2416		; Ans is now in CExreg
		; Apply to Apos...
		MOVFP	CEXreg,WREG
		ADDWF	Apos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	Apos+1,F
		; Apply to CH7pos...
		; First see if we need to invert...
		MOVLR	HIGH REVA
		BTFSC	REVA,0
		GOTO	AFM2f
		MOVLR	HIGH CEXreg
		COMF	CEXreg
		COMF	CEXreg+1
		INCF	CEXreg
		BTFSC	ALUSTA,C
		INCF	CEXreg+1
AFM2f
		MOVLR	HIGH CEXreg
		MOVFP	CEXreg,WREG
		ADDWF	CH7pos,F
		MOVFP	CEXreg+1,WREG
		ADDWFC	CH7pos+1,F
AFM2e
AFM3
		RETURN

ApplyFixedMixersPrior
	; If the FixedFirst flag is clear then exit
		MOVLR	HIGH FixedFirst
		BTFSS	FixedFirst,0
		RETURN
	; Now do the processing...
		CALL	Move2Mix
		CALL	CalculateFixedMixers	
		RETURN

; This function is designed to apply the fixed mixers used for the
; follwoing functions:
;	VTAIL		Rudder and Elevator mix
;	ELEVON		Aileron and Elevator mix
;	DUALA		Dual aileron
;	Throttle hold	Using channel 5
;	Idle up		Using channel 8
ApplyFixedMixers
	; Calculate the fixed mixer functions...
		; If the FixedFirst flag is clear...
		MOVLR	HIGH FixedFirst
		BTFSC	FixedFirst,0
		GOTO	AFM0
		CALL	Move2Mix
		CALL	CalculateFixedMixers
AFM0
	; Throttle hold. If set then channel 5 is used to enable
	; the throttle hold.		
		MOVLR	HIGH THOLD
		BTFSS	THOLD,0
		GOTO	AFM4
		; Here if the Throttle hold is enabled.
		MOVLR	HIGH SWTHOLD
		MOVFP	SWTHOLD,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	AFM4
		MOVLR	HIGH THOLD
		MOVFP	THOLDp,WREG
		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		MOVE	CEXreg,Tpos
	; Idle up. If set then channel 8 is used to enable
	; two idle up levels
AFM4
		MOVLR	HIGH IDLEUP
		BTFSS	IDLEUP,0
		GOTO	AFM5
		; Here if idle up is enabled, test switch
		MOVLR	HIGH SWIDLEUP1
		MOVFP	SWIDLEUP1,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	AFM4a
		MOVLR	HIGH IDLEUPpA
		MOVFP	IDLEUPpA,WREG
		GOTO	AFM4c
		; Test for idle up position 2
AFM4a		MOVLR	HIGH SWIDLEUP2
		MOVFP	SWIDLEUP2,WREG
		CALL	SwitchTest
		BTFSS	ALUSTA,C
		GOTO	AFM5
		MOVLR	HIGH IDLEUPpB
		MOVFP	IDLEUPpB,WREG
		; WREG has the idle up percentage...
AFM4c		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		MOVEC	D'10',BXreg
		CALL	Mult1616
		; Test IDLE position, if less that CEXreg then set throttle
		; position to CEXreg
		MOVFP	CEXreg,WREG
		SUBWF	Tpos,W
		MOVFP	CEXreg+1,WREG
		SUBWFB	Tpos+1,W
		BTFSS	WREG,7
		GOTO	AFM5
		MOVE	CEXreg,Tpos
AFM5
		RETURN

; This function applies the translation table, pointed to by the MS 4 bits
; of Breg, to the 16 bit value in AXreg.
Translation
	; Exit if table address is 0
		MOVFF	Breg,WREG
		ANDLW	0F0
		BTFSC	ALUSTA,Z
		RETURN
		MOVE	AXreg,Pos
	; If AXreg is neg, change its sign...
		BTFSS	AXreg+1,7
		GOTO	Trans1
		COMF	AXreg
		COMF	AXreg+1
		INCF	AXreg
		BTFSC	ALUSTA,C
		INCF	AXreg+1
Trans1
	; Here if we have a table address in Breg
	; Calculate the table index
		MOVE	AXreg,CEXreg
		MOVLW	D'100'
		MOVWF	DEXreg
		CALL	Divide168
		MOVLB	HIGH EEXreg
		CLRF	EEXreg+1
		; CEXreg now contains the index into the tables number defined
		; in the upper 4 bit of Breg. Test this value, if its greater than
		; 9 set it to 9
		MOVLW	D'9'
		CPFSLT	CEXreg
		GOTO	Trans5
		MOVFF	Breg,WREG
		SWAPF	WREG
		DECF	WREG
		ANDLW	0F
		BTFSC	WREG,3
		GOTO	Trans3
		GOTO	Trans4
	; Here if index is over 9, need to calculate a new remainder
Trans5
		MOVWF	CEXreg
		MOVE	AXreg,EEXreg
		MOVLW	LOW D'900'
		MOVLB	HIGH EEXreg
		SUBWF	EEXreg
		MOVLW	HIGH D'900'
		SUBWFB	EEXreg+1
		MOVFF	Breg,WREG
		SWAPF	WREG
		DECF	WREG
		ANDLW	0F
		BTFSC	WREG,3
		GOTO	Trans3		
	; Load pointer to global table
Trans4
		MULLW	D'11'
		MOVFP	PRODL,WREG
		ADDLW	LOW Table1
		ADDWF	CEXreg,W	; WREG now points to the correct byte of the
					; selected table
		MOVFF	WREG,FSR2L
		MOVLW	HIGH Table1
		MOVFF	WREG,FSR2H
		GOTO	Trans2
	; Load pointer to aircraft table
Trans3
		BCF	WREG,3
		MULLW	D'11'
		MOVFP	PRODL,WREG
		ADDLW	LOW Atable1
		ADDWF	CEXreg,W	; WREG now points to the correct byte of the
					; selected table
		MOVFF	WREG,FSR2L
		MOVLW	HIGH Atable1
		MOVFF	WREG,FSR2H
	; Here to load the table points and calculate the translation
Trans2	
		MOVFF	POSTINC2,Areg	; A point in table
		MOVFF	INDF2,Breg	; B point in table
		; AXreg = B - A
		MOVLB	HIGH AXreg
		MOVFF	Breg,AXreg
		MOVFF	Areg,WREG
		SUBWF	AXreg,F
		CLRF	AXreg+1
		BTFSC	AXreg,7
		SETF	AXreg+1
		
		MOVE	EEXreg,BXreg
		CALL	Mult1616
		MOVLW	D'10'
		MOVWF	DEXreg
		CALL	Divide168
		; A * 10 + CEXreg = the final position
		MOVFF	Areg,WREG
		MULLW	D'10'
		MOVFF	PRODL,WREG
		ADDWF	CEXreg,F
		MOVFF	PRODH,WREG
		ADDWFC	CEXreg+1,F
	; Now the final step, test the sign of Pos and adjust the result
		MOVE	CEXreg,AXreg
		MOVLB	HIGH Pos
		BTFSS	Pos+1,7
		RETURN
		; Here to change sign of AXreg
		MOVLB	HIGH AXreg
		COMF	AXreg
		COMF	AXreg+1
		INCF	AXreg
		BTFSC	ALUSTA,C
		INCF	AXreg+1
		RETURN
;
; This routine performes the mixer calculations for the mixer pointed
; to by FSR1. The mixer data tables are assumed to be located in bank 3.
; The From variable contains the from channel in the lower 4 bits
; and a translation table number in the upper 4 bits. If the upper 4 bits
; are zero then no translation table is applied.
; The To channel MSB is a flag indicating the results should be
; added to the To channel (0) or replace the To channel (1).
; To channel bit 6 set indicates indirect level control and the channel is in Gp
; To channel bit 5 set indicates indirect level control and the channel is in Gn
;
Mixer
	; Get the from channel
		MOVFP	POSTINC1,WREG
		MOVFF	WREG,Breg
		IORWF	WREG
		BTFSC	ALUSTA,Z
		RETURN			; Not selected so exit!
		CALL	GetFrom		; From channel data in AXreg
		CALL	Translation	; Apply the Translation table
		MOVE	AXreg,CXreg
		MOVFF	POSTINC1,Areg	; To channel to Areg
	; Now get the Zero point in percent
		MOVPF	POSTINC1,WREG
		MOVLR	HIGH AXreg
		MOVPF	WREG,AXreg
		CLRF	AXreg+1
		BTFSC	AXreg,7
		COMF	AXreg+1		; Sign extend
		MOVEC	d'10',BXreg
		CALL	Mult1616
		MOVE	CXreg,AXreg
		MOVFP	CEXreg,WREG
		SUBWF	AXreg,F
		MOVFP	CEXreg+1,WREG
		SUBWFB	AXreg+1,F
	; AXreg is now = ChannelPos - Zp. Test the sign and apply the correct
	; gain factor...
		BTFSC	AXreg+1,7
		GOTO	MixNeg
		; Here if positive...
		MOVPF	POSTINC1,WREG
		MOVLR	HIGH AXreg
		; Test bit 6 of the To channel in Areg. If this bit is
		; set then we are going to do indirect mixing and the 
		; 4 LSBs of WREG define the channel number that is the mix level
		BTFSS	Areg,6,A
		GOTO	MixNoIdP
		; Here if is an indirect mix...
		MOVE	WREG,CEXreg
		MOVE	AXreg,CXreg
		MOVFP	CEXreg,WREG
		CALL	GetFrom
		MOVE	AXreg,CEXreg
		MOVLW	D'10'
		MOVWF	DEXreg
		CALL	Divide168
		MOVE	CXreg,AXreg
		MOVFP	CEXreg,WREG
MixNoIdP
		MOVWF	BXreg
		CLRF	BXreg+1
		BTFSC	BXreg,7
		COMF	BXreg+1		; Sign extend
		CALL	Mult1616
		MOVEC	D'100',DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416
		MOVE	CEXreg,AXreg
		MOVF	Areg,W,A
		CALL	ApplyMix
		RETURN
MixNeg		; Here if negative...
		MOVPF	POSTINC1,WREG
		MOVPF	POSTINC1,WREG
		MOVLR	HIGH AXreg
		; Test bit 5 of the To channel in Areg. If this bit is
		; set then we are going to do indirect mixing and the 
		; 4 LSBs of WREG define the channel number that is the mix level
		BTFSS	Areg,5,A
		GOTO	MixNoIdN
		; Here if is an indirect mix...
		MOVPF	WREG,CEXreg
		MOVE	AXreg,CXreg
		MOVFP	CEXreg,WREG
		CALL	GetFrom
		MOVE	AXreg,CEXreg
		MOVLW	D'10'
		MOVWF	DEXreg
		CALL	Divide168
		MOVE	CXreg,AXreg
		MOVFP	CEXreg,WREG
MixNoIdN
		MOVWF	BXreg
		CLRF	BXreg+1
		BTFSC	BXreg,7
		COMF	BXreg+1		; Sign extend
		CALL	Mult1616
		MOVEC	D'100',DEXreg
		CLRF	DEXreg+2
		CLRF	DEXreg+3
		CALL	Divide2416
		MOVE	CEXreg,AXreg
		MOVF	Areg,W,A
		CALL	ApplyMix
		RETURN


; This function will switch the aircraft parameters between
; the selected aircraft and the alternate aircraft. This 
; function is only valid in the RUN mode. An Alternate Aircraft
; array is used to support multiple switches, if more than one
; switch is on the higher array index takes precedence.
AlternateAircraft
	; Save the timer variables
		MOVEC	CNTmode,Src
		MOVEC	TempBlock,Dst
		MOVLW	5
		MOVWF	Cnt
		CALLF	BlkMove
	; Search the alternate aircraft array looking for a active 
	; selection. 
		MOVLW	LOW AltAircraft	+ (2 * NumAlt) - 1	; Point to end of array
		MOVFF	WREG,FSR2L
		MOVLW	HIGH Backup
		MOVFF	WREG,FSR2H
		MOVLW	NumAlt			; Load counter
		MOVFF	WREG,Creg
	; Loop through all the alternate aircraft entries
AAloop
		MOVFF	POSTDEC2,WREG		; Get the alternate aircraft number
		IORWF	WREG			; Set flags
		BTFSC	STATUS,Z
		GOTO	AAnext
		; Here with non zero aircraft number
		MOVFF	INDF2,WREG		; Get the switch code
		CALL	SwitchTest
		BTFSC	STATUS,C
		GOTO	AAselected		; Load the selected aircraft
	; Advance to next entry and loop till done
AAnext
		MOVFF	POSTDEC2,WREG		; Advance to next array entry
		DECFSZ	Creg,F,A
		GOTO	AAloop
	; Exit if no alternate aircraft located. Make sure the default aircraft is loaded
		MOVFF	DefaultAircraft,WREG
		MOVLB	HIGH Aircraft
		CPFSEQ	Aircraft
		GOTO	AAload	
		RETURN
	; Here to load the selected aircraft
AAselected
		MOVFF	POSTINC2,WREG
		MOVFF	POSTINC2,WREG		; Get the aircraft number 
		; If this aircraft is loaded then exit
		MOVLB	HIGH Aircraft
		CPFSEQ	Aircraft
		GOTO	AAload
		RETURN
	; Here to load the aircraft
AAload
		MOVFF	WREG,Aircraft
		CALL	LoadAircraft
		; Restore the timer variables
		MOVEC	TempBlock,Src
		MOVEC	CNTmode,Dst
		MOVLW	5
		MOVWF	Cnt
		CALLF	BlkMove
		RETURN		


; This function moves data from the Src to Dst. Cnt contains the number
; of bytes to move.
; Uses: Areg
;	Indirect reg set 1 used for source
;	Indirect reg set 2 used for destination
BlkMove
	; Set up the regesters
		MOVLB	HIGH Src
		MOVF	Src,W
		MOVWF	FSR1L	
		MOVF	Src+1,W
		MOVWF	FSR1H	

		MOVLB	HIGH Dst
		MOVF	Dst,W
		MOVWF	FSR2L	
		MOVF	Dst+1,W
		MOVWF	FSR2H	
	; Get source byte
BlkMove1
		MOVFF	POSTINC1,WREG
		MOVFF	WREG,POSTINC2
	; Loop till all are sent...
		MOVLB	HIGH Cnt
		DECFSZ	Cnt
		GOTO	BlkMove1
		RETURN

;
; This function is called to initialize the button ID byte.
;
ButtonIDinit
	; Clear the switch ID byte
		MOVLB	HIGH SWID
		CLRF	SWID
	; Do the aileron DR
		MOVLB	HIGH SWAILDR
		MOVF	SWAILDR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF		SWID,0
	; Do the elevator DR
		MOVLB	HIGH SWELEDR
		MOVF	SWELEDR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF	    SWID,1
	; Do the rudder DR
		MOVLB	HIGH SWRUDDR
		MOVF	SWRUDDR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF		SWID,2
	; Do the preset
		MOVLB	HIGH SWPRESET
		MOVF	SWPRESET,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF		SWID,3
	; Do the Auto Trim
		MOVLB	HIGH SWATRIM
		MOVF	SWATRIM,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF		SWID,4
	; Do the Snap R
		MOVLB	HIGH SWSNAPR
		MOVF	SWSNAPR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF		SWID,5
	; Do the Snap L
		MOVLB	HIGH SWSNAPL
		MOVF	SWSNAPL,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		BTFSC	ALUSTA,C,A
		BSF		SWID,6
	; Bye!
		RETURN
;
; This function looks at the button image ports and prints the name of the
; last change, if one has been detected. This message will be displayed for
; a few seconds.
;
ButtonID
	; Set display to line 2
		MOVLW	LINE2
		CALL	LCDsendCMD
	; Test each funcion looking for a state change
		; Aileron DR
		MOVLB	HIGH SWAILDR
		MOVF	SWAILDR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		CLRF	WREG,A
		BSF		WREG,0,A
		ANDWF	SWID,W
		; If carry flag is set and z flag is clear then no change
		BTFSS	ALUSTA,C,A
		GOTO	BID0
		BTFSS	ALUSTA,Z,A
		GOTO	BIDELE
		; Here with a change
		BTG		SWID,0
		PrintMess IDAILLOW
		GOTO	BIDEXIT
		; If carry flag is clear and z flag is set then no change
BID0
		BTFSC	ALUSTA,C,A
		GOTO	BIDELE
		BTFSC	ALUSTA,Z,A
		GOTO	BIDELE
		; Here with a change
		BTG		SWID,0
		PrintMess IDAILHI
		GOTO	BIDEXIT
BIDELE
		; Elevator DR
		MOVLB	HIGH SWELEDR
		MOVF	SWELEDR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		CLRF	WREG,A
		BSF		WREG,1,A
		ANDWF	SWID,W
		; If carry flag is set and z flag is clear then no change
		BTFSS	ALUSTA,C,A
		GOTO	BID1
		BTFSS	ALUSTA,Z,A
		GOTO	BIDRUD
		; Here with a change
		BTG		SWID,1
		PrintMess IDELELOW
		GOTO	BIDEXIT
		; If carry flag is clear and z flag is set then no change
BID1
		BTFSC	ALUSTA,C,A
		GOTO	BIDRUD
		BTFSC	ALUSTA,Z,A
		GOTO	BIDRUD
		; Here with a change
		BTG		SWID,1
		PrintMess IDELEHI
		GOTO	BIDEXIT
BIDRUD
		; Rudder DR
		MOVLB	HIGH SWRUDDR
		MOVF	SWRUDDR,W
		CALL	SwitchTest
		MOVLB	HIGH SWID
		CLRF	WREG,A
		BSF		WREG,2,A
		ANDWF	SWID,W
		; If carry flag is set and z flag is clear then no change
		BTFSS	ALUSTA,C,A
		GOTO	BID2
		BTFSS	ALUSTA,Z,A
		GOTO	BIDPRESET
		; Here with a change
		BTG		SWID,2
		PrintMess IDRUDLOW
		GOTO	BIDEXIT
		; If carry flag is clear and z flag is set then no change
BID2
		BTFSC	ALUSTA,C,A
		GOTO	BIDPRESET
		BTFSC	ALUSTA,Z,A
		GOTO	BIDPRESET
		; Here with a change
		BTG		SWID,2
		PrintMess IDRUDHI
		GOTO	BIDEXIT
BIDPRESET
		; Preset
		MOVLB	HIGH SWPRESET
		MOVF	SWPRESET,W
		CALL	SwitchTest
		; If carry flag is set and bit 3 is not then display message.
		MOVLB	HIGH SWID
		BTFSS	ALUSTA,C,A
		GOTO	BID3
		BTFSC	SWID,3
		GOTO	BIDAUTOT
		BTG		SWID,3
		PrintMess IDPRESET
		GOTO	BIDEXIT
BID3
		BCF	SWID,3
BIDAUTOT
		; Auto trim
		MOVLB	HIGH SWATRIM
		MOVF	SWATRIM,W
		CALL	SwitchTest
		; If carry flag is set and bit 4 is not then display message.
		MOVLB	HIGH SWID
		BTFSS	ALUSTA,C,A
		GOTO	BID4
		BTFSC	SWID,4
		GOTO	BIDSNAPR
		BTG		SWID,4
		PrintMess IDAUTOT
		GOTO	BIDEXIT
BID4
		BCF	SWID,4
BIDSNAPR
		; SNAP right
		MOVLB	HIGH SWSNAPR
		MOVF	SWSNAPR,W
		CALL	SwitchTest
		; If carry flag is set and bit 5 is not then display message.
		MOVLB	HIGH SWID
		BTFSS	ALUSTA,C,A
		GOTO	BID5
		BTFSC	SWID,5
		GOTO	BIDSNAPL
		BTG		SWID,5
		PrintMess IDSNAPR
		GOTO	BIDEXIT
BID5
		BCF	SWID,5
BIDSNAPL
		; SNAP left
		MOVLB	HIGH SWSNAPL
		MOVF	SWSNAPL,W
		CALL	SwitchTest
		; If carry flag is set and bit 6 is not then display message.
		MOVLB	HIGH SWID
		BTFSS	ALUSTA,C,A
		GOTO	BID6
		BTFSC	SWID,6
		GOTO	BIDNEXT
		BTG	SWID,6
		PrintMess IDSNAPL
		GOTO	BIDEXIT
BID6
		BCF	SWID,6
BIDNEXT
		RETURN
BIDEXIT
		MOVLW	D'80'
		MOVWF	TimeOut5
		RETURN


;
; This function will test the switch code passed in WREG. If the
; code is true then the Carry flag is set, else its reset. Here
; is the definition of a switch code:
;   
;   7 6 5 4 3 2 1 0
;   x x x x x x x x
;   | | | | | | | +-- \
;   | | | | | | +----  > Bit position, 0 to 7
;   | | | | | +------ /
;   | | | | +-------- Port select, 0 = PORTD, 1 = PORTE
;   | | | +---------- ON  \ If both the ON and OFF bits are set then
;   | | +------------ OFF / this is a control position switch
;   | +-------------- And with next bit
;   +---------------- Invert
;
; The port data is read from the debounced data saved in regs:
;    PORTDimage
;    PORTEimage
;
; For control position mode (bits 4 and 5 set:
;   Bit codes
;      0 = aileron
;      1 = elevator
;      2 = rudder
;      3 = throttle
;   Invert bit 7 changes trigger polarity
;
SwitchTest
        ; Test if this is control position trigger flag
		BTFSS	WREG,5
		GOTO	STgo
		BTFSS	WREG,4
        	GOTO	STgo
        	; Here is bits 4 and 5 are set
        	; Load the percentage and multiply it by 10 to make it
        	; into normalized position
        	MOVWF	Areg		; Save WREG
        	ANDLW	07		; Get the selection bits
        	ADDLW	LOW ATP		; Make index to percentage
        	MOVWF	FSR1L
		MOVLW	HIGH ATP
		MOVWF	FSR1H
		MOVF	POSTINC1,WREG	; Load the percentage into Wreg
		; Multiply by 10
		MOVLR	HIGH AXreg
		MOVWF	AXreg
		CLRF	AXreg+1
		BTFSC	WREG,7
		SETF	AXreg+1		; Sign extended into AXreg
		MOVEC	D'10',BXreg
		CALL	Mult1616	; Result in CEXreg
		; Now load the position pointer
		MOVF	Areg,W,A
		ANDLW	07
		RLNCF	WREG		; Make it into a word pointer
		ADDLW	LOW ATpos
		MOVWF	FSR1L,A		; Load the position pointer
		MOVLW	HIGH ATpos
		MOVF	FSR1H
		MOVF	POSTINC1,W,A
		MOVFF	POSTINC1,Breg	; Load the position
		; Test the position
		MOVLB	HIGH CEXreg
		SUBWF	CEXreg
		MOVF	Breg,W,A
		SUBWFB	CEXreg+1,W   
		RLCF	WREG
		; If the Invert bit is set then invert the carry flag
		BTFSC	Areg,7,A
		RETURN
		BTG	ALUSTA,C,A
		RETURN
	; Test the on and off bits first
STgo
		BCF	ALUSTA,C,A
		BTFSC	WREG,5
		RETURN
		BSF	ALUSTA,C,A
		BTFSC	WREG,4
		RETURN
	; Now process the swith options...
		MOVLB	HIGH Atemp
		MOVWF	Atemp		; Save WREG
		CLRF	Btemp
	; If the And with next bit is set then set the LSB of Btemp
		BTFSC	WREG,6,A
		BSF	Btemp,0
		ANDLW	07		; get just the 3 LSBs
		INCF	WREG
		BSF	ALUSTA,C,A	; Set the carry flag
ST00
		RLCF	Btemp,F
		DECFSZ	WREG
		GOTO	ST00
	; Now the proper bit is set in Btemp
		MOVF	PORTDimage,W
		BTFSC	Atemp,3
		MOVF	PORTEimage,W
		ANDWF	Btemp,W
		BSF	ALUSTA,C,A
		CPFSEQ	Btemp
		BCF	ALUSTA,C,A
	; Test if the invert flag is set
		BTFSC	Atemp,7
		BTG	ALUSTA,C,A	
		RETURN

INCLUDE		<tach.asm>
INCLUDE		<ui.asm>

;
; This function is called at startup to load a set of default parameters
; into bank 2, bank 3 and bank 4.
;
LoadDefaults
	; Bank2
	; Set table pointer
		MOVLW	UPPER DFTgeneral
		MOVWF	TBLPTRU,A
		MOVLW	HIGH DFTgeneral
		MOVWF	TBLPTRH,A
		MOVLW	LOW DFTgeneral
		MOVWF	TBLPTRL,A
	; Load counter
		MOVLW	00
		MOVWF	Areg,A
	; Setup indirection regs
		MOVLW	HIGH BNK2
		MOVWF	FSR1H,A
		MOVLW	LOW BNK2
		MOVWF	FSR1L,A
LoadDefaults1
		TBLRD*+
		MOVF	TABLAT,W,A
		MOVWF	POSTINC1,A
		DECF	Areg,F,A
		TBLRD*+
		MOVF	TABLAT,W,A
		MOVWF	POSTINC1,A
		DECFSZ	Areg,F,A
		GOTO	LoadDefaults1
LoadAircraftDefaults
	; Bank3	
	; Set table pointer
		MOVLW	UPPER DFTaircraft
		MOVWF	TBLPTRU,A
		MOVLW	HIGH DFTaircraft
		MOVWF	TBLPTRH,A
		MOVLW	LOW DFTaircraft
		MOVWF	TBLPTRL,A
	; Setup counter
		MOVLW	00
		MOVWF	Areg,A
	; Setup indirection
		MOVLW	HIGH BNK3
		MOVWF	FSR1H,A
		MOVLW	LOW BNK3
		MOVWF	FSR1L,A
LoadDefaults2
		TBLRD*+
		MOVF	TABLAT,W,A
		MOVWF	POSTINC1,A
		DECF	Areg,F,A
		TBLRD*+
		MOVF	TABLAT,W,A
		MOVWF	POSTINC1,A
		DECFSZ	Areg,F,A
		GOTO	LoadDefaults2
	; Bank4	
	; Set table pointer
		MOVLW	UPPER DFTaircraft2
		MOVWF	TBLPTRU,A
		MOVLW	HIGH DFTaircraft2
		MOVWF	TBLPTRH,A
		MOVLW	LOW DFTaircraft2
		MOVWF	TBLPTRL,A
	; Setup counter
		MOVLW	00
		MOVWF	Areg,A
	; Setup indirection
		MOVLW	HIGH BNK4
		MOVWF	FSR1H,A
		MOVLW	LOW BNK4
		MOVWF	FSR1L,A
LoadDefaults3
		TBLRD*+
		MOVF	TABLAT,W,A
		MOVWF	POSTINC1,A
		DECF	Areg,F,A
		TBLRD*+
		MOVF	TABLAT,W,A
		MOVWF	POSTINC1,A
		DECFSZ	Areg,F,A
		GOTO	LoadDefaults3
		RETURN

ifdef           ECMA1010display
INCLUDE         <DataS.asm>
else
INCLUDE         <data.asm>
endif

;
; The following default tables are loaded instead of the Sprom for general setup parameters
; and aircraft specific setting. These are loaded if the Preset and Auto Trim buttons are
; held down at power up. These tables also hold the default data used to format the SPROM.
;
DFTgeneral	DB 01,00,0F,00,0D2,00,00,00,03,00,0D2,00,00,00,01E,00			;200
		DB 0D2,00,00,080,012,01B,01,066,03,079,01,03C,01,02E,03,0AE		;210
		DB 01,013,01,026,03,095,01,062,01,073,00,086,04,012,01,08B		;220
		DB 04,07,01,0C8,04,05,01,02A,04,029,01,032,02,037,02,03B		;230
		DB 02,02F,02,00,00,08,00,01,04,09,010,019,024,031,040,051		;240
		DB 064,00,013,024,033,040,04B,054,05B,060,063,064,00,01,02,03		;250
		DB 06,0C,015,022,033,049,064,00,01B,031,042,04F,058,05E,061,062		;260
		DB 063,064,00,0A,014,01E,028,032,03C,046,050,05A,064,00,014,028		;270
		DB 03C,050,064,050,03C,028,014,00,00,05,0A,0F,014,019,028,037		;280
		DB 046,055,064,00,0F,01E,02D,03C,04B,050,055,05A,05F,064,0A,0A		;290
		DB 00,00,010,090,01,0FF,00,0A5,0E7,0C0,09,0F3,00,00,0DC,05		;2A0
		DB 094,011,01,02,03,04,00,00,0FF,058,01,00,01,02,083,04			;2B0
		DB 05,06,07,08,09,0A,0B,08C,08D,0E,0F,00,00,00,00,00			;2C0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;2D0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;2E0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;2F0

DFTaircraft	DB 04D,04F,044,045,04C,020,030,031,020,020,020,020,020,020,020,020	;300
		DB 00,00,01,0B8,0B,00,01,03C,019,00,00,00,00,01,0B8,0B			;310
		DB 00,01,03C,019,00,00,00,00,01,0B8,0B,00,01,03C,019,00			;320
		DB 00,00,00,0FE,0A0,0F,019,01,0D0,07,00,01,0B8,0B,00,01			;330
		DB 0B8,0B,00,01,0B8,0B,00,01,0B8,0B,00,01,032,0FF,032,00		;340
		DB 032,00,032,00,0CE,0FF,0CE,00,0CE,00,0CE,00,00,00,00,014		;350
		DB 014,00,00,00,0A,0A,00,00,00,0A,0A,00,00,00,0A,0A			;360
		DB 00,00,0F4,01,0A,00,00,00,0A,0A,00,00,00,0A,0A,00			;370
		DB 00,00,0A,0A,00,00,00,0A,0A,00,00,00,0A,0A,00,00			;380
		DB 00,0A,0A,00,00,00,0A,0A,00,00,00,00,00,00,00,0A			;390
		DB 00,00,00,00,00,02,00,00,00,00,00,00,00,0FF,00,01			;3A0
		DB 02,083,04,05,06,07,089,08B,04B,08C,0D,08E,08F,01,00,08		;3B0
		DB 010,00,07,04B,08C,04,00,020,00,00,00,00,00,0FF,0D,00			;3C0
		DB 020,00,020,00,020,00,020,00,020,00,00,01,04,09,010,019		;3D0
		DB 024,031,040,051,064,00,013,024,033,040,04B,054,05B,060,063,064	;3E0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;3F0

DFTaircraft2	DB 02,01,03,04,05,06,07,08,00,00,00,00,00,00,00,00			;400
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;410
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;420
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;430
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;440
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;450
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;460
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;470
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;480
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;490
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;4A0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;4B0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;4C0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;4D0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;4E0
		DB 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00			;4F0

; This area is reserved to store the general and aircraft configuration data. 

ConfigLoc	org	0x10000
	
CFGgeneral	RES	D'256'

CFGaircraft	RES	(D'256') * 2 * NumAircraft
	
                END     ;required directive

